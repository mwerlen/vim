diff -urN vim71/runtime/autoload/adacomplete.vim vim71_ada/runtime/autoload/adacomplete.vim
--- vim71/runtime/autoload/adacomplete.vim	2007-05-05 19:34:16.000000000 +0200
+++ vim71_ada/runtime/autoload/adacomplete.vim	2008-01-16 16:46:40.000000000 +0100
@@ -1,13 +1,13 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada omnicompletion file
 "     Language:	Ada (2005)
-"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "   Maintainer:	Martin Krischik
-"      $Author: karsten $
-"	 $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/adacomplete.vim $
+"      $Author: karsten $
+"	 $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/adacomplete.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		26.05.2006 MK improved search for begin of word.
 "		16.07.2006 MK Ada-Mode as vim-ball
diff -urN vim71/runtime/autoload/ada.vim vim71_ada/runtime/autoload/ada.vim
--- vim71/runtime/autoload/ada.vim	2007-05-05 20:02:22.000000000 +0200
+++ vim71_ada/runtime/autoload/ada.vim	2008-01-16 16:46:40.000000000 +0100
@@ -1,14 +1,16 @@
 "------------------------------------------------------------------------------
 "  Description: Perform Ada specific completion & tagging.
 "     Language: Ada (2005)
-"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
-"   Maintainer: Martin Krischik
+"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
+"		Taylor Venable <taylor@metasyntax.net>
 "		Neil Bird <neil@fnxweb.com>
-"      $Author: karsten $
-"	 $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/ada.vim $
+"		Ned Okie <nokie@radford.edu>
+"      $Author: karsten $
+"	 $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/ada.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		26.05.2006 MK ' should not be in iskeyword.
 "		16.07.2006 MK Ada-Mode as vim-ball
@@ -17,6 +19,10 @@
 "		05.11.2006 MK Bram suggested not to use include protection for
 "			      autoload
 "		05.11.2006 MK Bram suggested to save on spaces
+"		08.07.2007 TV fix mapleader problems.
+"	        09.05.2007 MK Session just won't work no matter how much
+"			      tweaking is done
+"		19.09.2007 NO still some mapleader problems
 "    Help Page: ft-ada-functions
 "------------------------------------------------------------------------------
 
@@ -425,7 +431,15 @@
    execute '!ctags --excmd=number ' . l:Filename
 endfunction ada#Create_Tags
 
-function ada#Switch_Session (New_Session)   "{{{1
+" Section: ada#Switch_Session {{{1
+"
+function ada#Switch_Session (New_Session)
+   " 
+   " you should not save to much date into the seession since they will
+   " be sourced
+   "
+   set sessionoptions=buffers,curdir,folds,globals,resize,slash,tabpages,tabpages,unix,winpos,winsize
+
    if a:New_Session != v:this_session
       "
       "  We actualy got a new session - otherwise there
@@ -437,18 +451,23 @@
 
       let v:this_session = a:New_Session
 
-      if filereadable (v:this_session)
-	 execute 'source ' . v:this_session
-      endif
+      "if filereadable (v:this_session)
+	 "execute 'source ' . v:this_session
+      "endif
 
       augroup ada_session
 	 autocmd!
 	 autocmd VimLeavePre * execute 'mksession! ' . v:this_session
       augroup END
+      "
+      "if exists ("g:Tlist_Auto_Open") && g:Tlist_Auto_Open
+	 "TlistOpen
+      "endif
+
    endif
 
    return
-endfunction ada#Switch_Session	 "}}}1
+endfunction ada#Switch_Session	
 
 " Section: GNAT Pretty Printer folding {{{1
 "
@@ -546,18 +565,23 @@
 	\ a:Keys		 .
 	\" <C-O>:" . a:Command . "<CR>"
    else
+      if exists("g:mapleader")
+         let l:leader = g:mapleader
+      else
+         let l:leader = '\'
+      endif
       execute
 	\ "50amenu " .
 	\ "Ada."  . escape(a:Text, ' ') .
-	\ "<Tab>" . escape(g:mapleader . "a" . a:Keys , '\') .
+	\ "<Tab>" . escape(l:leader . "a" . a:Keys , '\') .
 	\ " :"	  . a:Command . "<CR>"
       execute
 	\ "nnoremap <buffer>" .
-	\ escape(g:mapleader . "a" . a:Keys , '\') .
+	\ escape(l:leader . "a" . a:Keys , '\') .
 	\" :" . a:Command
       execute
 	\ "inoremap <buffer>" .
-	\ escape(g:mapleader . "a" . a:Keys , '\') .
+	\ escape(l:leader . "a" . a:Keys , '\') .
 	\" <C-O>:" . a:Command
    endif
    return
@@ -566,10 +590,15 @@
 " Section: ada#Map_Popup {{{2
 "
 function ada#Map_Popup (Text, Keys, Command)
+   if exists("g:mapleader")
+      let l:leader = g:mapleader
+   else
+      let l:leader = '\'
+   endif
    execute
      \ "50amenu " .
      \ "PopUp."   . escape(a:Text, ' ') .
-     \ "<Tab>"	  . escape(g:mapleader . "a" . a:Keys , '\') .
+     \ "<Tab>"	  . escape(l:leader . "a" . a:Keys , '\') .
      \ " :"	  . a:Command . "<CR>"
 
    call ada#Map_Menu (a:Text, a:Keys, a:Command)
diff -urN vim71/runtime/autoload/decada.vim vim71_ada/runtime/autoload/decada.vim
--- vim71/runtime/autoload/decada.vim	2007-05-05 19:25:32.000000000 +0200
+++ vim71_ada/runtime/autoload/decada.vim	2008-01-16 16:46:41.000000000 +0100
@@ -1,14 +1,14 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada/Dec Ada compiler file
 "     Language: Ada (Dec Ada)
-"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
-"   Maintainer:	Martin Krischik
-"      $Author: karsten $
-"        $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/decada.vim $
+"   Maintainer:	Martin Krischik <krischik@users.sourceforge.net>
+"      $Author: karsten $
+"        $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/decada.vim $
 "      History: 21.07.2006 MK New Dec Ada
 "               15.10.2006 MK Bram's suggestion for runtime integration
 "               05.11.2006 MK Bram suggested not to use include protection for
@@ -45,7 +45,7 @@
       call ada#Switch_Session (a:1)
    elseif argc() == 0 && strlen (v:servername) > 0
       call ada#Switch_Session (
-	 \ expand('~')[0:-2] . ".vimfiles.session]" .
+	 \ expand('~')[0:-2] . ".vimfiles.session]decada_" .
 	 \ v:servername . ".vim")
    endif
    return
diff -urN vim71/runtime/autoload/gnat.vim vim71_ada/runtime/autoload/gnat.vim
--- vim71/runtime/autoload/gnat.vim	2007-05-05 20:18:20.000000000 +0200
+++ vim71_ada/runtime/autoload/gnat.vim	2008-01-16 16:46:46.000000000 +0100
@@ -1,14 +1,15 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada/GNAT compiler file
 "     Language: Ada (GNAT)
-"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
-"   Maintainer:	Martin Krischik
-"      $Author: karsten $
-"        $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/gnat.vim $
+"   Maintainer:	Martin Krischi <krischik@users.sourceforge.net>k
+"		Ned Okie <nokie@radford.edu>
+"      $Author: karsten $
+"        $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/autoload/gnat.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		16.07.2006 MK Ada-Mode as vim-ball
 "		05.08.2006 MK Add session support
@@ -16,6 +17,7 @@
 "               05.11.2006 MK Bram suggested not to use include protection for
 "                             autoload
 "		05.11.2006 MK Bram suggested to save on spaces
+"		19.09.2007 NO use project file only when there is a project
 "    Help Page: compiler-gnat
 "------------------------------------------------------------------------------
 
@@ -71,13 +73,19 @@
       execute 'mksession! ' . v:this_session
    endif
 
-   if strlen (self.Project_File) > 0
-      call ada#Switch_Session (
-	 \ expand('~') . "/vimfiles/session/" .
-	 \ fnamemodify (self.Project_File, ":t:r") . ".vim")
-   else
-      call ada#Switch_Session ('')
-   endif
+   "if strlen (self.Project_File) > 0
+      "if has("vms")
+	 "call ada#Switch_Session (
+	    "\ expand('~')[0:-2] . ".vimfiles.session]gnat_" .
+	    "\ fnamemodify (self.Project_File, ":t:r") . ".vim")
+      "else
+	 "call ada#Switch_Session (
+	    "\ expand('~') . "/vimfiles/session/gnat_" .
+	    "\ fnamemodify (self.Project_File, ":t:r") . ".vim")
+      "endif
+   "else
+      "call ada#Switch_Session ('')
+   "endif
 
    return
 endfunction gnat#Set_Project_File				     " }}}1
diff -urN vim71/runtime/compiler/decada.vim vim71_ada/runtime/compiler/decada.vim
--- vim71/runtime/compiler/decada.vim	2007-05-05 20:09:54.000000000 +0200
+++ vim71_ada/runtime/compiler/decada.vim	2008-01-16 16:37:03.000000000 +0100
@@ -1,16 +1,17 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada/Dec Ada compiler file
 "     Language: Ada (Dec Ada)
-"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
-"   Maintainer:	Martin Krischik
-"      $Author: karsten $
-"        $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/compiler/decada.vim $
+"   Maintainer:	Martin Krischik <krischik@users.sourceforge.net>
+"      $Author: karsten $
+"        $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/compiler/decada.vim $
 "      History: 21.07.2006 MK New Dec Ada
 "               15.10.2006 MK Bram's suggestion for runtime integration
+"               08.09.2006 MK Correct double load protection.
 "    Help Page: compiler-decada
 "------------------------------------------------------------------------------
 
@@ -24,6 +25,13 @@
 
 if !exists("g:decada")
    let g:decada = decada#New ()
+
+   call ada#Map_Menu (
+     \'Dec Ada.Build',
+     \'<F7>',
+     \'call decada.Make ()')
+
+   call g:decada.Set_Session ()
 endif
 
 if exists(":CompilerSet") != 2
@@ -33,16 +41,9 @@
    command -nargs=* CompilerSet setlocal <args>
 endif
 
-call g:decada.Set_Session ()
-
 execute "CompilerSet makeprg="     . escape (g:decada.Make_Command, ' ')
 execute "CompilerSet errorformat=" . escape (g:decada.Error_Format, ' ')
 
-call ada#Map_Menu (
-  \'Dec Ada.Build',
-  \'<F7>',
-  \'call decada.Make ()')
-
 finish " 1}}}
 
 "------------------------------------------------------------------------------
diff -urN vim71/runtime/compiler/gnat.vim vim71_ada/runtime/compiler/gnat.vim
--- vim71/runtime/compiler/gnat.vim	2007-05-05 20:04:19.000000000 +0200
+++ vim71_ada/runtime/compiler/gnat.vim	2008-01-16 16:37:03.000000000 +0100
@@ -1,17 +1,19 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada/GNAT compiler file
 "     Language: Ada (GNAT)
-"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
-"   Maintainer:	Martin Krischik
-"      $Author: karsten $
-"        $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/compiler/gnat.vim $
+"   Maintainer:	Martin Krischi <krischik@users.sourceforge.net>k
+"		Ned Okie <nokie@radford.edu>
+"      $Author: karsten $
+"        $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/compiler/gnat.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		16.07.2006 MK Ada-Mode as vim-ball
 "               15.10.2006 MK Bram's suggestion for runtime integration
+"		19.09.2007 NO use project file only when there is a project
 "    Help Page: compiler-gnat
 "------------------------------------------------------------------------------
 
@@ -46,6 +48,8 @@
       \ 'GNAT.Set Projectfile\.\.\.',
       \ ':SetProject',
       \ 'call gnat.Set_Project_File ()')
+
+   call g:gnat.Set_Session ()
 endif
 
 if exists(":CompilerSet") != 2
@@ -55,8 +59,6 @@
    command -nargs=* CompilerSet setlocal <args>
 endif
 
-call g:gnat.Set_Session ()
-
 execute "CompilerSet makeprg="     . escape (g:gnat.Get_Command('Make'), ' ')
 execute "CompilerSet errorformat=" . escape (g:gnat.Error_Format, ' ')
 
diff -urN vim71/runtime/doc/ft_ada.txt vim71_ada/runtime/doc/ft_ada.txt
--- vim71/runtime/doc/ft_ada.txt	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/doc/ft_ada.txt	2008-01-16 16:37:03.000000000 +0100
@@ -0,0 +1,516 @@
+*ft_ada.txt*	    Ada File type Plug-ins	      Last change: 2007 Seb 17
+
+
+		    ADA FILE TYPE PLUG-INS REFERENCE MANUAL~
+
+ADA								      *ada.vim*
+
+1.  Syntax Highlighting			    |ft-ada-syntax|
+2.  Plug-in				    |ft-ada-plugin|
+3.  Omni Completion			    |ft-ada-omni|
+    3.1 Omni Completion with "gnat xref"	|gnat-xref|
+    3.2 Omni Completion with "ctags"		|ada-ctags|
+4.  Compiler Support			    |ada-compiler|
+    4.1 GNAT					|compiler-gnat|
+    4.1 Dec Ada					|compiler-decada|
+5.  References				    |ada-reference|
+    5.1 Options					|ft-ada-options|
+    5.2 Functions				|ft-ada-functions|
+    5.3 Commands				|ft-ada-commands|
+    5.4 Variables				|ft-ada-variables|
+    5.5 Constants				|ft-ada-contstants|
+8.  Extra Plug-ins			    |ada-extra-plugins|
+
+==============================================================================
+1. Syntax Highlighting ~
+							       *ft-ada-syntax*
+
+This mode is designed for the 2005 edition of Ada ("Ada 2005"), which includes
+support for objected-programming, protected types, and so on.  It handles code
+written for the original Ada language ("Ada83", "Ada87", "Ada95") as well,
+though code which uses Ada 2005-only keywords will be wrongly colored (such
+code should be fixed anyway).  For more information about Ada, see
+http://www.adapower.com.
+
+The Ada mode handles a number of situations cleanly.
+
+For example, it knows that the "-" in "-5" is a number, but the same character
+in "A-5" is an operator.  Normally, a "with" or "use" clause referencing
+another compilation unit is coloured the same way as C's "#include" is coloured.
+If you have "Conditional" or "Repeat" groups coloured differently, then "end
+if" and "end loop" will be coloured as part of those respective groups.
+
+You can set these to different colours using vim's "highlight" command (e.g.,
+to change how loops are displayed, enter the command ":hi Repeat" followed by
+the colour specification; on simple terminals the colour specification
+ctermfg=White often shows well).
+
+There are several options you can select in this Ada mode. See|ft-ada-options|
+for a complete list.
+
+To enable them, assign a value to the option.  For example, to turn one on:
+ >
+    > let g:ada_standard_types = 1
+>
+To disable them use ":unlet".  Example:
+>
+    > unlet g:ada_standard_types
+
+You can just use ":" and type these into the command line to set these
+temporarily before loading an Ada file.  You can make these option settings
+permanent by adding the "let" command(s), without a colon, to your "~/.vimrc"
+file.
+
+Even on a slow (90Mhz) PC this mode works quickly, but if you find the
+performance unacceptable, turn on |g:ada_withuse_ordinary|.
+
+Syntax folding instructions (|fold-syntax|) are added when |g:ada_folding| is
+set.
+
+==============================================================================
+2. File type Plug-in ~
+					       *ft-ada-indent* *ft-ada-plugin*
+
+The Ada plug-in provides support for:
+
+ - auto indenting	(|indent.txt|)
+ - insert completion	(|i_CTRL-N|)
+ - user completion	(|i_CTRL-X_CTRL-U|)
+ - tag searches		(|tagsrch.txt|)
+ - Quick Fix		(|quickfix.txt|)
+ - backspace handling	(|'backspace'|)
+ - comment handling	(|'comments'|, |'commentstring'|)
+
+The plug-in only activates the features of the Ada mode whenever an Ada
+files is opened and add adds Ada related entries to the main and pop-up menu.
+
+==============================================================================
+3. Omni Completion ~
+								 *ft-ada-omni*
+
+The Ada omni-completions (|i_CTRL-X_CTRL-O|) uses tags database created either
+by "gnat xref -v" or the "exuberant Ctags (http://ctags.sourceforge.net).  The
+complete function will automatically detect which tool was used to create the
+tags file.
+
+------------------------------------------------------------------------------
+3.1 Omni Completion with "gnat xref" ~
+								   *gnat-xref*
+
+GNAT XREF uses the compiler internal information (ali-files) to produce the
+tags file. This has the advantage to be 100% correct and the option of deep
+nested analysis. However the code must compile, the generator is quite
+slow and the created tags file contains only the basic Ctags information for
+each entry - not enough for some of the more advanced Vim code browser
+plug-ins.
+
+NOTE: "gnat xref -v" is very tricky to use as it has almost no diagnostic
+       output - If nothing is printed then usually the parameters are wrong.
+       Here some important tips:
+
+1)  You need to compile your code first and use the "-aO" option to point to
+    your .ali files.
+2)  "gnat xref -v ../Include/adacl.ads" won't work - use  the "gnat xref -v
+    -aI../Include adacl.ads" instead.
+3)  "gnat xref -v -aI../Include *.ad?" won't work - use "cd ../Include" and
+    then "gnat xref -v *.ad?"
+4)  Project manager support is completely broken - don't even try "gnat xref
+    -Padacl.gpr".
+5)  VIM is faster when the tags file is sorted - use "sort --unique
+    --ignore-case --output=tags tags" .
+6)  Remember to insert "!_TAG_FILE_SORTED 2 %sort ui" as first line to mark
+    the file assorted.
+
+------------------------------------------------------------------------------
+3.2 Omni Completion with "ctags"~
+								   *ada-ctags*
+
+Exuberant Ctags uses it's own multi-language code parser. The parser is quite
+fast, produces a lot of extra informations (hence the name "Exuberant Ctags")
+and can run on files which currently do not compile.
+
+There are also lots of other Vim-tools which use exuberant Ctags.
+
+You will need to install a version of the Exuberant Ctags which has Ada
+support patched in. Such a version is available from the GNU Ada Project
+(http://gnuada.sourceforge.net).
+
+The Ada parser for Exuberant Ctags is fairly new - don't expect complete
+support yet.
+
+==============================================================================
+4.  Compiler Support ~
+								*ada-compiler*
+
+The Ada mode supports more then one Ada compiler and will automatically load the
+compiler set in|g:ada_default_compiler|whenever an Ada source is opened. The
+provided compiler plug-ins are split into the actual compiler plug-in and a
+collection of support functions and variables. This allows the easy
+development of specialized compiler plug-ins fine tuned to your development
+environment.
+
+------------------------------------------------------------------------------
+4.1 GNAT ~
+							       *compiler-gnat*
+
+GNAT is the only free (beer and speech) Ada compiler available. There are
+several version available which differentiate in the licence terms used.
+
+The GNAT compiler plug-in will perform a compile on pressing <F7> and then
+immediately shows the result. You can set the project file to be used by
+setting:
+ >
+ > call g:gnat.Set_Project_File ('my_project.gpr')
+
+Setting a project file will also create a Vim session (|views-sessions|) so -
+like with the GPS - opened files, window positions etc. will remembered
+separately for all projects.
+
+								*gnat_members*
+GNAT OBJECT ~
+
+							       *g:gnat.Make()*
+g:gnat.Make()
+		Calls|g:gnat.Make_Command|and displays the result inside a
+               |quickfix| window.
+
+							     *g:gnat.Pretty()*
+g:gnat.Pretty()
+		Calls|g:gnat.Pretty_Command|
+
+							       *g:gnat.Find()*
+g:gnat.Find()
+		Calls|g:gnat.Find_Command|
+
+							       *g:gnat.Tags()*
+g:gnat.Tags()
+		Calls|g:gnat.Tags_Command|
+
+						   *g:gnat.Set_Project_File()*
+g:gnat.Set_Project_File([{file}])
+		Set gnat project file and load associated session.  An open
+		project will be closed and the session written.  If called
+		without file name the file selector opens for selection of a
+		project file. If called with an empty string then the project
+		and associated session are closed.
+
+							 *g:gnat.Project_File*
+g:gnat.Project_File	string
+		Current project file.
+
+							 *g:gnat.Make_Command*
+g:gnat.Make_Command	string
+		External command used for|g:gnat.Make()| (|'makeprg'|).
+
+						       *g:gnat.Pretty_Program*
+g:gnat.Pretty_Program	string
+		External command used for|g:gnat.Pretty()|
+
+							 *g:gnat.Find_Program*
+g:gnat.Find_Program	string
+		External command used for|g:gnat.Find()|
+
+							 *g:gnat.Tags_Command*
+g:gnat.Tags_Command	string
+		External command used for|g:gnat.Tags()|
+
+							 *g:gnat.Error_Format*
+g:gnat.Error_Format	string
+		Error format (|'errorformat'|)
+
+------------------------------------------------------------------------------
+4.2 Dec Ada ~
+					    *compiler-hpada* *compiler-decada*
+					*compiler-vaxada* *compiler-compaqada*
+
+Dec Ada (also known by - in chronological order - VAX Ada, Dec Ada, Compaq Ada
+and HP Ada) is a fairly dated Ada 83 compiler. Support is basic: <F7> will
+compile the current unit.
+
+The Dec Ada compiler expects the package name and not the file name to be
+passed a parameter. The compiler plug-in supports the usual file name
+convention to convert the file into a unit name. For separates both '-' and
+'__' are allowed.
+
+							      *decada_members*
+DEC ADA OBJECT ~
+
+							     *g:decada.Make()*
+g:decada.Make()		function
+		Calls|g:decada.Make_Command|and displays the result inside a
+               |quickfix| window.
+
+							*g:decada.Unit_Name()*
+g:decada.Unit_Name()	function
+		Get the Unit name for the current file.
+
+						       *g:decada.Make_Command*
+g:decada.Make_Command	string
+		External command used for|g:decadat.Make()| (|'makeprg'|).
+
+						       *g:decada.Error_Format*
+g:decada.Error_Format|	string
+		Error format (|'errorformat'|).
+
+==============================================================================
+5. References ~
+							       *ada-reference*
+
+------------------------------------------------------------------------------
+5.1 Options ~
+							      *ft-ada-options*
+
+							*g:ada_standard_types*
+g:ada_standard_types	bool (true when exists)
+		Highlight types in package Standard (e.g., "Float")
+
+							  *g:ada_space_errors*
+						  *g:ada_no_trail_space_error*
+						    *g:ada_no_tab_space_error*
+							 *g:ada_all_tab_usage*
+g:ada_space_errors	 bool (true when exists)
+		Highlight extraneous errors in spaces ...
+		g:ada_no_trail_space_error
+		    - but ignore trailing spaces at the end of a line
+		g:ada_no_tab_space_error
+		    - but ignore tabs after spaces
+		g:ada_all_tab_usage
+		    - highlight all tab use
+
+							   *g:ada_line_errors*
+g:ada_line_errors	  bool (true when exists)
+		Highlight lines which are to long. Note: This highlighting
+		option is quite CPU intensive.
+
+							 *g:ada_rainbow_color*
+g:ada_rainbow_color	  bool (true when exists)
+		Use rainbow colours for '(' and ')'. You need the
+		rainbow_parenthesis for this to work
+
+							       *g:ada_folding*
+g:ada_folding		  set ('sigpft')
+		Use folding for Ada sources.
+		    's':    activate syntax folding on load
+			'p':    fold packages
+			'f':    fold functions and procedures
+			't':    fold types
+			'c':    fold conditionals
+		    'g':    activate gnat pretty print folding on load
+			'i':    lone 'is' folded with line above
+			'b':	lone 'begin' folded with line above
+			'p':	lone 'private' folded with line above
+			'x':	lone 'exception' folded with line above
+		    'i':    activate indent folding on load
+
+		Note: Syntax folding is in an early (unuseable) stage and
+		      indent or gnat pretty folding is suggested.
+
+		For gnat pretty folding to work the following settings are
+		suggested: -cl3 -M79 -c2 -c3 -c4 -A1 -A2 -A3 -A4 -A5
+
+		For indent folding to work the following settings are
+		suggested: shiftwidth=3 softtabstop=3
+
+								*g:ada_abbrev*
+g:ada_abbrev		  bool (true when exists)
+		Add some abbreviations. This feature more or less superseded
+		by the various completion methods.
+
+						      *g:ada_withuse_ordinary*
+g:ada_withuse_ordinary	  bool (true when exists)
+		Show "with" and "use" as ordinary keywords (when used to
+		reference other compilation units they're normally highlighted
+		specially).
+
+							 *g:ada_begin_preproc*
+g:ada_begin_preproc	  bool (true when exists)
+		Show all begin-like keywords using the colouring of C
+		preprocessor commands.
+
+						    *g:ada_omni_with_keywords*
+g:ada_omni_with_keywords
+		Add Keywords, Pragmas, Attributes to omni-completions
+		(|compl-omni|). Note: You can always complete then with user
+		completion (|i_CTRL-X_CTRL-U|).
+
+						      *g:ada_extended_tagging*
+g:ada_extended_tagging	  enum ('jump', 'list')
+		use extended tagging, two options are available
+		    'jump': use tjump to jump.
+		    'list': add tags quick fix list.
+		Normal tagging does not support function or operator
+		overloading as these features are not available in C and
+		tagging was originally developed for C.
+
+						   *g:ada_extended_completion*
+g:ada_extended_completion
+		Uses extended completion for <C-N> and <C-R> completions
+		(|i_CTRL-N|). In this mode the '.' is used as part of the
+		identifier so that 'Object.Method' or 'Package.Procedure' are
+		completed together.
+
+						       *g:ada_gnat_extensions*
+g:ada_gnat_extensions	  bool (true when exists)
+		 Support GNAT extensions.
+
+					       *g:ada_with_gnat_project_files*
+g:ada_with_gnat_project_files	 bool (true when exists)
+		 Add gnat project file keywords and Attributes.
+
+						      *g:ada_default_compiler*
+g:ada_default_compiler	  string
+		set default compiler. Currently supported is 'gnat' and
+		'decada'.
+
+An "exists" type is a boolean is considered true when the variable is defined
+and false when the variable is undefined. The value which the variable is
+set makes no difference.
+
+------------------------------------------------------------------------------
+5.3 Commands ~
+							     *ft-ada-commands*
+
+:AdaRainbow							 *:AdaRainbow*
+		Toggles rainbow colour (|g:ada_rainbow_color|) mode for
+		'(' and ')'
+
+:AdaLines							   *:AdaLines*
+		Toggles line error (|g:ada_line_errors|) display
+
+:AdaSpaces							  *:AdaSpaces*
+		Toggles space error (|g:ada_space_errors|) display.
+
+:AdaTagDir							  *:AdaTagDir*
+		Creates tags file for the directory of the current file.
+
+:AdaTagFile							 *:AdaTagFile*
+		Creates tags file for the current file.
+
+:AdaTypes							   *:AdaTypes*
+		Toggles standard types (|g:ada_standard_types|) colour.
+
+:GnatFind							   *:GnatFind*
+		Calls |g:gnat.Find()|
+
+:GnatPretty							 *:GnatPretty*
+		Calls |g:gnat.Pretty()|
+
+:GnatTags							   *:GnatTags*
+		Calls |g:gnat.Tags()|
+
+------------------------------------------------------------------------------
+5.3 Variables ~
+							    *ft-ada-variables*
+
+								      *g:gnat*
+g:gnat			    object
+		Control object which manages GNAT compiles.  The object
+		is created when the first Ada source code is loaded provided
+		that |g:ada_default_compiler|is set to 'gnat'. See|gnat_members|
+		for details.
+
+								    *g:decada*
+g:decada		      object
+		Control object which manages Dec Ada compiles.	The object
+		is created when the first Ada source code is loaded provided
+		that |g:ada_default_compiler|is set to 'decada'. See
+	       |decada_members|for details.
+
+------------------------------------------------------------------------------
+5.4 Constants ~
+							    *ft-ada-constants*
+                                                             ft-ada-constants
+
+All constants are locked. See |:lockvar| for details.
+
+							     *g:ada#WordRegex*
+g:ada#WordRegex		string
+		Regular expression to search for Ada words
+
+							  *g:ada#DotWordRegex*
+g:ada#DotWordRegex	string
+		Regular expression to search for Ada words separated by dots.
+
+							       *g:ada#Comment*
+g:ada#Comment		string
+		Regular expression to search for Ada comments
+
+							      *g:ada#Keywords*
+g:ada#Keywords		list of dictionaries
+		List of keywords, attributes etc. pp. in the format used by
+		omni completion. See |complete-items| for details.
+
+							   *g:ada#Ctags_Kinds*
+g:ada#Ctags_Kinds	dictionary of lists
+		Dictionary of the various kinds of items which the Ada support
+		for Ctags generates.
+
+------------------------------------------------------------------------------
+5.2 Functions ~
+							    *ft-ada-functions*
+
+ada#Word([{line}, {col}])					  *ada#Word()*
+		Return full name of Ada entity under the cursor (or at given
+		line/column), stripping white space/newlines as necessary.
+
+ada#List_Tag([{line}, {col}])				      *ada#Listtags()*
+		List all occurrences of the Ada entity under the cursor (or at
+		given line/column) inside the quick-fix window
+
+ada#Jump_Tag ({ident}, {mode})				      *ada#Jump_Tag()*
+		List all occurrences of the Ada entity under the cursor (or at
+		given line/column) in the tag jump list. Mode can either be
+		'tjump' or 'stjump'.
+
+ada#Create_Tags ({option})				   *ada#Create_Tags()*
+		Creates tag file using Ctags. The option can either be 'file'
+		for the current file, 'dir' for the directory of the current
+		file or a file name.
+
+gnat#Insert_Tags_Header()			   *gnat#Insert_Tags_Header()*
+		Adds the tag file header (!_TAG_) information to the current
+		file which are missing from the GNAT XREF output.
+
+ada#Switch_Syntax_Option ({option})		  *ada#Switch_Syntax_Option()*
+		Toggles highlighting options on or off. Used for the Ada menu.
+
+								  *gnat#New()*
+gnat#New ()
+		Create a new gnat object. See |g:gnat| for details.
+
+
+==============================================================================
+8. Extra Plugins ~
+							   *ada-extra-plugins*
+
+You can optionally install the following extra plug-in. They work well with Ada
+and enhance the ability of the Ada mode.:
+
+backup.vim
+	http://www.vim.org/scripts/script.php?script_id=1537
+	Keeps as many backups as you like so you don't have to.
+
+rainbow_parenthsis.vim
+	http://www.vim.org/scripts/script.php?script_id=1561
+	Very helpful since Ada uses only '(' and ')'.
+
+nerd_comments.vim
+	http://www.vim.org/scripts/script.php?script_id=1218
+	Excellent commenting and uncommenting support for almost any
+	programming language.
+
+matchit.vim
+	http://www.vim.org/scripts/script.php?script_id=39
+	'%' jumping for any language. The normal '%' jump only works for '{}'
+	style languages. The Ada mode will set the needed search patters.
+
+taglist.vim
+	http://www.vim.org/scripts/script.php?script_id=273
+	Source code explorer sidebar. There is a patch for Ada available.
+
+The GNU Ada Project distribution (http://gnuada.sourceforge.net) of Vim
+contains all of the above.
+
+==============================================================================
+vim: textwidth=78 nowrap tabstop=8 shiftwidth=4 softtabstop=4 noexpandtab
+vim: filetype=help
diff -urN vim71/runtime/ftplugin/ada.vim vim71_ada/runtime/ftplugin/ada.vim
--- vim71/runtime/ftplugin/ada.vim	2007-05-05 19:17:45.000000000 +0200
+++ vim71_ada/runtime/ftplugin/ada.vim	2008-01-16 16:37:03.000000000 +0100
@@ -1,14 +1,15 @@
 "------------------------------------------------------------------------------
 "  Description: Perform Ada specific completion & tagging.
 "     Language: Ada (2005)
-"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
-"   Maintainer: Martin Krischik
+"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
+"		Taylor Venable <taylor@metasyntax.net>
 "		Neil Bird <neil@fnxweb.com>
-"      $Author: karsten $
-"	 $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/ftplugin/ada.vim $
+"      $Author: karsten $
+"	 $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/ftplugin/ada.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		26.05.2006 MK ' should not be in iskeyword.
 "		16.07.2006 MK Ada-Mode as vim-ball
@@ -17,6 +18,7 @@
 "               05.11.2006 MK Bram suggested not to use include protection for
 "                             autoload
 "		05.11.2006 MK Bram suggested to save on spaces
+"		08.07.2007 TV fix default compiler problems.
 "    Help Page: ft-ada-plugin
 "------------------------------------------------------------------------------
 " Provides mapping overrides for tag jumping that figure out the current
@@ -30,7 +32,7 @@
 endif
 
 " Don't load another plugin for this buffer
-let b:did_ftplugin = 38
+let b:did_ftplugin = 45
 
 "
 " Temporarily set cpoptions to ensure the script loads OK
@@ -104,8 +106,17 @@
       \ s:notend . '\<record\>:\<end\>\s\+\<record\>'
 endif
 
+
 " Section: Compiler {{{1
 "
+if ! exists("g:ada_default_compiler")
+   if has("vms")
+      let g:ada_default_compiler = 'decada'
+   else
+      let g:ada_default_compiler = 'gnat'
+   endif
+endif
+
 if ! exists("current_compiler")			||
    \ current_compiler != g:ada_default_compiler
    execute "compiler " . g:ada_default_compiler
diff -urN vim71/runtime/indent/ada.vim vim71_ada/runtime/indent/ada.vim
--- vim71/runtime/indent/ada.vim	2007-05-05 19:25:37.000000000 +0200
+++ vim71_ada/runtime/indent/ada.vim	2008-01-16 16:37:02.000000000 +0100
@@ -1,19 +1,21 @@
 "------------------------------------------------------------------------------
 "  Description: Vim Ada indent file
 "     Language: Ada (2005)
-"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
-"   Maintainer: Martin Krischik
+"   Maintainer: Martin Krischik <krischik@users.sourceforge.net>
 "		Neil Bird <neil@fnxweb.com>
-"      $Author: karsten $
-"	 $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/indent/ada.vim $
+"		Ned Okie <nokie@radford.edu>
+"      $Author: karsten $
+"	 $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/indent/ada.vim $
 "      History: 24.05.2006 MK Unified Headers
 "		16.07.2006 MK Ada-Mode as vim-ball
 "		15.10.2006 MK Bram's suggestion for runtime integration
 "		05.11.2006 MK Bram suggested to save on spaces
+"		19.09.2007 NO g: missing before ada#Comment
 "    Help Page: ft-vim-indent
 "------------------------------------------------------------------------------
 " ToDo:
@@ -27,7 +29,7 @@
    finish
 endif
 
-let b:did_indent = 1
+let b:did_indent = 45
 
 setlocal indentexpr=GetAdaIndent()
 setlocal indentkeys-=0{,0}
@@ -58,7 +60,7 @@
 " Seems to work OK as it 'starts' with the indent of the /previous/ line.
 function s:MainBlockIndent (prev_indent, prev_lnum, blockstart, stop_at)
    let lnum = a:prev_lnum
-   let line = substitute( getline(lnum), ada#Comment, '', '' )
+   let line = substitute( getline(lnum), g:ada#Comment, '', '' )
    while lnum > 1
       if a:stop_at != ''  &&  line =~ '^\s*' . a:stop_at  &&  indent(lnum) < a:prev_indent
 	 return a:prev_indent
@@ -72,7 +74,7 @@
       let lnum = prevnonblank(lnum - 1)
       " Get previous non-blank/non-comment-only line
       while 1
-	 let line = substitute( getline(lnum), ada#Comment, '', '' )
+	 let line = substitute( getline(lnum), g:ada#Comment, '', '' )
 	 if line !~ '^\s*$' && line !~ '^\s*#'
 	    break
 	 endif
@@ -116,7 +118,7 @@
       " Get previous non-blank/non-comment-only line
       while 1
 	 let line = getline(lnum)
-	 let line = substitute( line, ada#Comment, '', '' )
+	 let line = substitute( line, g:ada#Comment, '', '' )
 	 if line !~ '^\s*$'
 	    break
 	 endif
@@ -143,7 +145,8 @@
       let lnum = prevnonblank(lnum - 1)
       " Get previous non-blank/non-comment-only line
       while 1
-	 let line = substitute( getline(lnum), ada#Comment, '', '' )
+	 let line = substitute( getline(lnum), g:ada#Comment, '', '' )
+	 
 	 if line !~ '^\s*$' && line !~ '^\s*#'
 	    break
 	 endif
@@ -222,7 +225,7 @@
       exe lnum
       exe 'normal! $F)%'
       if getline('.') =~ '^\s*('
-	 " Dire layout - use previous indent (could check for ada#Comment here)
+	 " Dire layout - use previous indent (could check for g:ada#Comment here)
 	 let ind = indent( prevnonblank( line('.')-1 ) )
       else
 	 let ind = indent('.')
diff -urN vim71/runtime/macros/svnignore.bash vim71_ada/runtime/macros/svnignore.bash
--- vim71/runtime/macros/svnignore.bash	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/macros/svnignore.bash	2008-01-16 16:37:02.000000000 +0100
@@ -0,0 +1,9 @@
+#!/bin/bash
+
+svn propedit                \
+    --editor-cmd="gvim -f"  \
+    svn:ignore              \
+    "${@}"                  ;
+
+# vim: textwidth=0 nowrap tabstop=8 shiftwidth=4 softtabstop=4 expandtab
+# vim: filetype=sh encoding=utf-8 fileformat=unix foldmethod=marker nospell
diff -urN vim71/runtime/macros/svnignore.btm vim71_ada/runtime/macros/svnignore.btm
--- vim71/runtime/macros/svnignore.btm	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/macros/svnignore.btm	2008-01-16 16:37:02.000000000 +0100
@@ -0,0 +1,27 @@
+::!C:\Bin\4Portable\App\4\4nt.EXE
+::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+::  Description: Works like "tail -f" .
+::          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+::   Maintainer: Martin Krischik
+::               Jason Heddings (vim at heddway dot com)
+::      $Author: karsten $
+::        $Date: 2008/02/11 16:41:46 $
+::      Version: 3.0
+::    $Revision: 1.1 $
+::     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/macros/svnignore.btm $
+::      History: 17.11.2007 Edit svn:ignore data
+::    Help Page: tail.txt
+::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+
+svn propedit                ^
+    --editor-cmd="gvim -f"  ^
+    svn:ignore              ^
+    "%[$]"
+
+::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+::   Copyright (C) 2006  Martin Krischik
+::
+::   Vim is Charityware - see ":help license" or uganda.txt for licence details.
+::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
+:: vim: textwidth=0 nowrap tabstop=8 shiftwidth=4 softtabstop=4 noexpandtab
+:: vim: filetype=btm encoding=utf-8 fileformat=unix foldmethod=marker nospell
diff -urN vim71/runtime/macros/svnignore.zsh vim71_ada/runtime/macros/svnignore.zsh
--- vim71/runtime/macros/svnignore.zsh	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/macros/svnignore.zsh	2008-01-16 16:37:02.000000000 +0100
@@ -0,0 +1,29 @@
+#!/bin/zsh
+#------------------------------------------------------------------------------
+#  Description: Works like "tail -f" .
+#          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+#   Maintainer: Martin Krischik
+#               Jason Heddings (vim at heddway dot com)
+#      $Author: karsten $
+#        $Date: 2008/02/11 16:41:46 $
+#      Version: 3.0
+#    $Revision: 1.1 $
+#     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/macros/svnignore.zsh $
+#      History: 17.11.2007 Edit svn:ignore data
+#    Help Page: tail.txt
+#------------------------------------------------------------------------------
+
+setopt No_X_Trace;
+
+svn propedit                \
+    --editor-cmd="gvim -f"  \
+    svn:ignore              \
+    "${=@}"                  ;
+
+#------------------------------------------------------------------------------
+#   Copyright (C) 2006  Martin Krischik
+#
+#   Vim is Charityware - see ":help license" or uganda.txt for licence details.
+#------------------------------------------------------------------------------
+# vim: textwidth=0 nowrap tabstop=8 shiftwidth=4 softtabstop=4 noexpandtab
+# vim: filetype=zsh encoding=utf-8 fileformat=unix foldmethod=marker nospell
diff -urN vim71/runtime/macros/vim.bash vim71_ada/runtime/macros/vim.bash
--- vim71/runtime/macros/vim.bash	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/macros/vim.bash	2008-01-16 16:37:02.000000000 +0100
@@ -0,0 +1,191 @@
+#!/bin/echo usage: source
+########################################################### {{{1 ###########
+#  Description: Set alias names for a custom installed vim/ctags.
+#     Language: Bash Shell Script
+#          $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+#   Maintainer: Martin Krischik
+#      $Author: karsten $
+#        $Date: 2008/02/11 16:41:46 $
+#      Version: 3.6
+#    $Revision: 1.1 $
+#     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/macros/vim.bash $
+#      History: 26.07.2006 MK pretty new
+#        Usage: copy to /etc/profile.d and make world executable
+########################################################### }}}1 ###########
+
+
+if ! type lxpm 2>/dev/null 1>/dev/null; then
+
+    # Variablen
+    UName=$(uname)
+
+    case "${UName}" in					# {{{1
+	(Linux*)					# {{{2
+	    if test -x "/opt/gnat/tools/bin/vim"; then
+		declare -x VIM="/opt/gnat/tools";
+		declare -x VIMRUNTIME="${VIM}/share/vim/vim71";
+	    else
+		unset VIM 1>/dev/null 2>/dev/null;
+		unset VIMRUNTIME 1>/dev/null 2>/dev/null;
+	    fi;
+	;;						# }}}2
+	(CYGWIN*)					# {{{2
+	    if test -x "/opt/gnat/tools/bin/vim"; then
+		declare -x VIM="/opt/gnat/tools";
+		declare -x VIMRUNTIME="${VIM}/share/vim/vim71"
+	    else
+		unset VIM 1>/dev/null 2>/dev/null;
+		unset VIMRUNTIME 1>/dev/null 2>/dev/null;
+	    fi;
+	;;						# }}}2
+	(SunOS)						# {{{2
+	    if test -x "/opt/gnat/tools/bin/vim"; then
+		declare -x VIM="/opt/gnat/tools";
+		declare -x VIMRUNTIME="${VIM}/share/vim/vim71";
+	    elif test -x "${HOME}/opt/gnat/tools/bin/vim"; then
+		declare -x VIM="${HOME}/opt/gnat/tools";
+		declare -x VIMRUNTIME="${VIM}/share/vim/vim71"
+		PATH="${VIM}/bin:${PATH}"
+	    else
+		unset VIM 1>/dev/null 2>/dev/null;
+		unset VIMRUNTIME 1>/dev/null 2>/dev/null;
+	    fi
+	;;						# }}}2
+	(*)						# {{{2
+	;;						# }}}2
+    esac;						# }}}1
+
+    # Simple Functions
+
+    for i in ctags etags eview evim ex gview gvim gvimdiff rgview rgvim rview rvim view vim vimdiff vimtutor xxd; do # {{{1
+
+	case "${UName}" in				# {{{2
+	    (MINGW*)					# {{{3
+		if test -n "${VIM}"; then
+		    declare -x -f ${i};
+
+		    eval "function ${i} ()
+			{
+			${VIM}/vim71/gvim.exe \"\${@}\"
+			return;
+			}"
+		else
+		    unset -f ${i} 1>/dev/null 2>/dev/null;
+		fi;
+	    ;; # }}}3
+	    (Linux|CYGWIN*)				# {{{3
+		if test -n "${VIM}"; then
+		    declare -x -f ${i};
+
+		    eval "function ${i} ()
+			    {
+			    LD_LIBRARY_PATH=\"\${LD_LIBRARY_PATH}:${VIM}/lib\"  \
+			    \"${VIM}/bin/${i}\" \"\${@}\"			;
+			    return;
+			    }"
+		else
+		    unset -f ${i} 1>/dev/null 2>/dev/null;
+		fi;
+	    ;;						# }}}3
+	    (*)						# {{{3
+	    ;;						# }}}3
+	esac;						# }}}2
+    done;						# }}}1
+
+    # Server Functions
+
+    for i in lxpm med epm; do				# {{{1
+	declare -x -f ${i}
+
+	case "${UName}" in				# {{{2
+	    (MINGW*)					# {{{3
+		if test -n "${VIM}"; then
+		    eval "function ${i} ()
+			{
+			if test -z "\${1}"; then
+			    ${VIM}/vim71/gvim.exe --servername ${i} 1>/dev/null 2>/dev/null &
+			else
+			    ${VIM}/vim71/gvim.exe --servername ${i} --remote-silent \"\${@}\" 1>/dev/null 2>/dev/null &
+			fi;
+			return;
+			}"
+		else
+		    eval "function ${i} ()
+			{
+			if test -z "\${1}"; then
+			    gvim.exe --servername ${i} 1>/dev/null 2>/dev/null &
+			else
+			    gvim.exe --servername ${i} --remote-silent \"\${@}\" 1>/dev/null 2>/dev/null &
+			fi;
+			return;
+			}"
+		fi;
+	    ;;						# }}}3
+	    (Linux|CYGWIN*|SunOS)			# {{{3
+		if test -n "${VIM}"; then
+		    eval "function ${i} ()
+			{
+			if test -z \"\${1}\"; then
+			    LD_LIBRARY_PATH=\"\${LD_LIBRARY_PATH}:${VIM}/lib\"			\
+			    \"${VIM}/bin/gvim\" --servername \"${i} ${HOSTNAME}\" \"\${@}\"	\
+			    >/dev/null 2>/dev/null &
+			else
+			    LD_LIBRARY_PATH=\"\${LD_LIBRARY_PATH}:${VIM}/lib\"				    \
+			    \"${VIM}/bin/gvim\" --servername \"${i} ${HOSTNAME}\" --remote-silent \"\${@}\" \
+			    >/dev/null 2>/dev/null &
+			fi
+			return;
+			}"
+		else
+		    eval "function ${i} ()
+			{
+			if test -z \"\${1}\"; then
+			    gvim --servername \"${i} ${HOSTNAME}\" >/dev/null 2>/dev/null &
+			else
+			    gvim --servername \"${i} ${HOSTNAME}\" --remote-silent \"\${@}\" >/dev/null 2>/dev/null &
+			fi
+			return;
+			}"
+		fi;
+	    ;;						# }}}3
+	    (*)						# {{{3
+	    ;;						# }}}3
+	esac;						# }}}2
+    done;						# }}}1
+
+    # Some applications read the EDITOR variable to determine your favourite text
+    # editor. So uncomment the line below and enter the editor of your choice :-)
+    if test -n "${VIM}"; then
+	declare -x EDITOR="${VIM}/bin/gvim -f";
+	declare -x VISUAL="${VIM}/bin/gvim -f";
+    else
+	declare -x EDITOR="$(which gvim) -f";
+	declare -x VISUAL="$(which gvim) -f";
+    fi;
+    # Unset local Variablen
+
+    unset UName
+
+    printf "\e[42m%-30.30s : \e[43m %-40.40s \e[m\n" "$(basename ${BASH_SOURCE:-${0}})" "VIM 7.0 symbols set."
+
+fi;
+
+########################################################### {{{1 ###########
+#   Copyright (C) 2006	Martin Krischik
+#
+#   This program is free software; you can redistribute it and/or
+#   modify it under the terms of the GNU General Public License
+#   as published by the Free Software Foundation; either version 2
+#   of the License, or (at your option) any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#   GNU General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+########################################################### }}}1 ###########
+# vim: textwidth=0 nowrap tabstop=8 shiftwidth=4 softtabstop=4 noexpandtab
+# vim: filetype=sh encoding=utf-8 fileformat=unix foldmethod=marker
diff -urN vim71/runtime/macros/vim.zsh vim71_ada/runtime/macros/vim.zsh
--- vim71/runtime/macros/vim.zsh	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/macros/vim.zsh	2008-01-16 16:37:02.000000000 +0100
@@ -0,0 +1,17 @@
+#!/bin/echo usage: source
+
+setopt No_Verbose
+setopt No_X_Trace
+setopt Typeset_Silent;
+
+#
+# Bash script is zsh compatible
+#
+HOSTNAME="${HOSTNAME:-${HOST}}"
+BASH_SOURCE="$(basename ${0} .zsh).bash"
+source "$(dirname ${0})/${BASH_SOURCE}"
+unset BASH_SOURCE;
+
+############################################################# {{{1 ###########
+# vim: textwidth=0 nowrap tabstop=8 shiftwidth=4 softtabstop=4 expandtab
+# vim: filetype=zsh encoding=utf-8 fileformat=unix foldmethod=marker nospell
diff -urN vim71/runtime/plugin/matchit.vim vim71_ada/runtime/plugin/matchit.vim
--- vim71/runtime/plugin/matchit.vim	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/plugin/matchit.vim	2008-01-16 16:37:03.000000000 +0100
@@ -0,0 +1,814 @@
+"  matchit.vim: (global plugin) Extended "%" matching
+"  Last Change: Tue Oct 24 11:00 AM 2006 EDT
+"  Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
+"  Version:     1.12, for Vim 6.3+
+"  URL:		http://www.vim.org/script.php?script_id=39
+
+" Documentation:
+"  The documentation is in a separate file, matchit.txt .
+
+" Credits:
+"  Vim editor by Bram Moolenaar (Thanks, Bram!)
+"  Original script and design by Raul Segura Acevedo
+"  Support for comments by Douglas Potts
+"  Support for back references and other improvements by Benji Fisher
+"  Support for many languages by Johannes Zellner
+"  Suggestions for improvement, bug reports, and support for additional
+"  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
+"  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
+
+" Debugging:
+"  If you'd like to try the built-in debugging commands...
+"   :MatchDebug      to activate debugging for the current buffer
+"  This saves the values of several key script variables as buffer-local
+"  variables.  See the MatchDebug() function, below, for details.
+
+" TODO:  I should think about multi-line patterns for b:match_words.
+"   This would require an option:  how many lines to scan (default 1).
+"   This would be useful for Python, maybe also for *ML.
+" TODO:  Maybe I should add a menu so that people will actually use some of
+"   the features that I have implemented.
+" TODO:  Eliminate the MultiMatch function.  Add yet another argument to
+"   Match_wrapper() instead.
+" TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
+" TODO:  Make backrefs safer by using '\V' (very no-magic).
+" TODO:  Add a level of indirection, so that custom % scripts can use my
+"   work but extend it.
+
+" allow user to prevent loading
+" and prevent duplicate loading
+if exists("loaded_matchit") || &cp
+  finish
+endif
+let loaded_matchit = 1
+let s:last_mps = ""
+let s:last_words = ""
+
+let s:save_cpo = &cpo
+set cpo&vim
+
+nnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'n') <CR>
+nnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'n') <CR>
+vnoremap <silent> %  :<C-U>call <SID>Match_wrapper('',1,'v') <CR>m'gv``
+vnoremap <silent> g% :<C-U>call <SID>Match_wrapper('',0,'v') <CR>m'gv``
+onoremap <silent> %  v:<C-U>call <SID>Match_wrapper('',1,'o') <CR>
+onoremap <silent> g% v:<C-U>call <SID>Match_wrapper('',0,'o') <CR>
+
+" Analogues of [{ and ]} using matching patterns:
+nnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "n") <CR>
+nnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "n") <CR>
+vmap [% <Esc>[%m'gv``
+vmap ]% <Esc>]%m'gv``
+" vnoremap <silent> [% :<C-U>call <SID>MultiMatch("bW", "v") <CR>m'gv``
+" vnoremap <silent> ]% :<C-U>call <SID>MultiMatch("W",  "v") <CR>m'gv``
+onoremap <silent> [% v:<C-U>call <SID>MultiMatch("bW", "o") <CR>
+onoremap <silent> ]% v:<C-U>call <SID>MultiMatch("W",  "o") <CR>
+
+" text object:
+vmap a% <Esc>[%v]%
+
+" Auto-complete mappings:  (not yet "ready for prime time")
+" TODO Read :help write-plugin for the "right" way to let the user
+" specify a key binding.
+"   let g:match_auto = '<C-]>'
+"   let g:match_autoCR = '<C-CR>'
+" if exists("g:match_auto")
+"   execute "inoremap " . g:match_auto . ' x<Esc>"=<SID>Autocomplete()<CR>Pls'
+" endif
+" if exists("g:match_autoCR")
+"   execute "inoremap " . g:match_autoCR . ' <CR><C-R>=<SID>Autocomplete()<CR>'
+" endif
+" if exists("g:match_gthhoh")
+"   execute "inoremap " . g:match_gthhoh . ' <C-O>:call <SID>Gthhoh()<CR>'
+" endif " gthhoh = "Get the heck out of here!"
+
+let s:notslash = '\\\@<!\%(\\\\\)*'
+
+function! s:Match_wrapper(word, forward, mode) range
+  " In s:CleanUp(), :execute "set" restore_options .
+  let restore_options = (&ic ? " " : " no") . "ignorecase"
+  if exists("b:match_ignorecase")
+    let &ignorecase = b:match_ignorecase
+  endif
+  let restore_options = " ve=" . &ve . restore_options
+  set ve=
+  " If this function was called from Visual mode, make sure that the cursor
+  " is at the correct end of the Visual range:
+  if a:mode == "v"
+    execute "normal! gv\<Esc>"
+  endif
+  " In s:CleanUp(), we may need to check whether the cursor moved forward.
+  let startline = line(".")
+  let startcol = col(".")
+  " Use default behavior if called with a count or if no patterns are defined.
+  if v:count
+    exe "normal! " . v:count . "%"
+    return s:CleanUp(restore_options, a:mode, startline, startcol)
+  elseif !exists("b:match_words") || b:match_words == ""
+    silent! normal! %
+    return s:CleanUp(restore_options, a:mode, startline, startcol)
+  end
+
+  " First step:  if not already done, set the script variables
+  "   s:do_BR	flag for whether there are backrefs
+  "   s:pat	parsed version of b:match_words
+  "   s:all	regexp based on s:pat and the default groups
+  "
+  " Allow b:match_words = "GetVimMatchWords()" .
+  if b:match_words =~ ":"
+    let match_words = b:match_words
+  else
+    execute "let match_words =" b:match_words
+  endif
+" Thanks to Preben "Peppe" Guldberg and Bram Moolenaar for this suggestion!
+  if (match_words != s:last_words) || (&mps != s:last_mps) ||
+    \ exists("b:match_debug")
+    let s:last_words = match_words
+    let s:last_mps = &mps
+    if match_words !~ s:notslash . '\\\d'
+      let s:do_BR = 0
+      let s:pat = match_words
+    else
+      let s:do_BR = 1
+      let s:pat = s:ParseWords(match_words)
+    endif
+    " The next several lines were here before
+    " BF started messing with this script.
+    " quote the special chars in 'matchpairs', replace [,:] with \| and then
+    " append the builtin pairs (/*, */, #if, #ifdef, #else, #elif, #endif)
+    " let default = substitute(escape(&mps, '[$^.*~\\/?]'), '[,:]\+',
+    "  \ '\\|', 'g').'\|\/\*\|\*\/\|#if\>\|#ifdef\>\|#else\>\|#elif\>\|#endif\>'
+    let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
+      \ '\/\*:\*\/,#if\%(def\)\=:#else\>:#elif\>:#endif\>'
+    " s:all = pattern with all the keywords
+    let s:all = s:pat . (strlen(s:pat) ? "," : "") . default
+    let s:all = substitute(s:all, s:notslash . '\zs[,:]\+', '\\|', 'g')
+    let s:all = '\%(' . s:all . '\)'
+    " let s:all = '\%(' . substitute(s:all, '\\\ze[,:]', '', 'g') . '\)'
+    if exists("b:match_debug")
+      let b:match_pat = s:pat
+    endif
+  endif
+
+  " Second step:  set the following local variables:
+  "     matchline = line on which the cursor started
+  "     curcol    = number of characters before match
+  "     prefix    = regexp for start of line to start of match
+  "     suffix    = regexp for end of match to end of line
+  " Require match to end on or after the cursor and prefer it to
+  " start on or before the cursor.
+  let matchline = getline(startline)
+  if a:word != ''
+    " word given
+    if a:word !~ s:all
+      echohl WarningMsg|echo 'Missing rule for word:"'.a:word.'"'|echohl NONE
+      return s:CleanUp(restore_options, a:mode, startline, startcol)
+    endif
+    let matchline = a:word
+    let curcol = 0
+    let prefix = '^\%('
+    let suffix = '\)$'
+  " Now the case when "word" is not given
+  else	" Find the match that ends on or after the cursor and set curcol.
+    let regexp = s:Wholematch(matchline, s:all, startcol-1)
+    let curcol = match(matchline, regexp)
+    let endcol = matchend(matchline, regexp)
+    let suf = strlen(matchline) - endcol
+    let prefix = (curcol ? '^.*\%'  . (curcol + 1) . 'c\%(' : '^\%(')
+    let suffix = (suf ? '\)\%' . (endcol + 1) . 'c.*$'  : '\)$')
+    " If the match comes from the defaults, bail out.
+    if matchline !~ prefix .
+      \ substitute(s:pat, s:notslash.'\zs[,:]\+', '\\|', 'g') . suffix
+      silent! norm! %
+      return s:CleanUp(restore_options, a:mode, startline, startcol)
+    endif
+  endif
+  if exists("b:match_debug")
+    let b:match_match = matchstr(matchline, regexp)
+    let b:match_col = curcol+1
+  endif
+
+  " Third step:  Find the group and single word that match, and the original
+  " (backref) versions of these.  Then, resolve the backrefs.
+  " Set the following local variable:
+  " group = colon-separated list of patterns, one of which matches
+  "       = ini:mid:fin or ini:fin
+  "
+  " Reconstruct the version with unresolved backrefs.
+  let patBR = substitute(match_words.',',
+    \ s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
+  let patBR = substitute(patBR, s:notslash.'\zs:\{2,}', ':', 'g')
+  " Now, set group and groupBR to the matching group: 'if:endif' or
+  " 'while:endwhile' or whatever.  A bit of a kluge:  s:Choose() returns
+  " group . "," . groupBR, and we pick it apart.
+  let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
+  let i = matchend(group, s:notslash . ",")
+  let groupBR = strpart(group, i)
+  let group = strpart(group, 0, i-1)
+  " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
+  if s:do_BR " Do the hard part:  resolve those backrefs!
+    let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
+  endif
+  if exists("b:match_debug")
+    let b:match_wholeBR = groupBR
+    let i = matchend(groupBR, s:notslash . ":")
+    let b:match_iniBR = strpart(groupBR, 0, i-1)
+  endif
+
+  " Fourth step:  Set the arguments for searchpair().
+  let i = matchend(group, s:notslash . ":")
+  let j = matchend(group, '.*' . s:notslash . ":")
+  let ini = strpart(group, 0, i-1)
+  let mid = substitute(strpart(group, i,j-i-1), s:notslash.'\zs:', '\\|', 'g')
+  let fin = strpart(group, j)
+  "Un-escape the remaining , and : characters.
+  let ini = substitute(ini, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
+  let mid = substitute(mid, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
+  let fin = substitute(fin, s:notslash . '\zs\\\(:\|,\)', '\1', 'g')
+  " searchpair() requires that these patterns avoid \(\) groups.
+  let ini = substitute(ini, s:notslash . '\zs\\(', '\\%(', 'g')
+  let mid = substitute(mid, s:notslash . '\zs\\(', '\\%(', 'g')
+  let fin = substitute(fin, s:notslash . '\zs\\(', '\\%(', 'g')
+  " Set mid.  This is optimized for readability, not micro-efficiency!
+  if a:forward && matchline =~ prefix . fin . suffix
+    \ || !a:forward && matchline =~ prefix . ini . suffix
+    let mid = ""
+  endif
+  " Set flag.  This is optimized for readability, not micro-efficiency!
+  if a:forward && matchline =~ prefix . fin . suffix
+    \ || !a:forward && matchline !~ prefix . ini . suffix
+    let flag = "bW"
+  else
+    let flag = "W"
+  endif
+  " Set skip.
+  if exists("b:match_skip")
+    let skip = b:match_skip
+  elseif exists("b:match_comment") " backwards compatibility and testing!
+    let skip = "r:" . b:match_comment
+  else
+    let skip = 's:comment\|string'
+  endif
+  let skip = s:ParseSkip(skip)
+  if exists("b:match_debug")
+    let b:match_ini = ini
+    let b:match_tail = (strlen(mid) ? mid.'\|' : '') . fin
+  endif
+
+  " Fifth step:  actually start moving the cursor and call searchpair().
+  " Later, :execute restore_cursor to get to the original screen.
+  let restore_cursor = virtcol(".") . "|"
+  normal! g0
+  let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
+  normal! H
+  let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
+  execute restore_cursor
+  call cursor(0, curcol + 1)
+  " normal! 0
+  " if curcol
+  "   execute "normal!" . curcol . "l"
+  " endif
+  if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
+    let skip = "0"
+  else
+    execute "if " . skip . "| let skip = '0' | endif"
+  endif
+  let sp_return = searchpair(ini, mid, fin, flag, skip)
+  let final_position = "call cursor(" . line(".") . "," . col(".") . ")"
+  " Restore cursor position and original screen.
+  execute restore_cursor
+  normal! m'
+  if sp_return > 0
+    execute final_position
+  endif
+  return s:CleanUp(restore_options, a:mode, startline, startcol, mid.'\|'.fin)
+endfun
+
+" Restore options and do some special handling for Operator-pending mode.
+" The optional argument is the tail of the matching group.
+fun! s:CleanUp(options, mode, startline, startcol, ...)
+  execute "set" a:options
+  " Open folds, if appropriate.
+  if a:mode != "o"
+    if &foldopen =~ "percent"
+      normal! zv
+    endif
+    " In Operator-pending mode, we want to include the whole match
+    " (for example, d%).
+    " This is only a problem if we end up moving in the forward direction.
+  elseif (a:startline < line(".")) ||
+	\ (a:startline == line(".") && a:startcol < col("."))
+    if a:0
+      " Check whether the match is a single character.  If not, move to the
+      " end of the match.
+      let matchline = getline(".")
+      let currcol = col(".")
+      let regexp = s:Wholematch(matchline, a:1, currcol-1)
+      let endcol = matchend(matchline, regexp)
+      if endcol > currcol  " This is NOT off by one!
+	execute "normal!" . (endcol - currcol) . "l"
+      endif
+    endif " a:0
+  endif " a:mode != "o" && etc.
+  return 0
+endfun
+
+" Example (simplified HTML patterns):  if
+"   a:groupBR	= '<\(\k\+\)>:</\1>'
+"   a:prefix	= '^.\{3}\('
+"   a:group	= '<\(\k\+\)>:</\(\k\+\)>'
+"   a:suffix	= '\).\{2}$'
+"   a:matchline	=  "123<tag>12" or "123</tag>12"
+" then extract "tag" from a:matchline and return "<tag>:</tag>" .
+fun! s:InsertRefs(groupBR, prefix, group, suffix, matchline)
+  if a:matchline !~ a:prefix .
+    \ substitute(a:group, s:notslash . '\zs:', '\\|', 'g') . a:suffix
+    return a:group
+  endif
+  let i = matchend(a:groupBR, s:notslash . ':')
+  let ini = strpart(a:groupBR, 0, i-1)
+  let tailBR = strpart(a:groupBR, i)
+  let word = s:Choose(a:group, a:matchline, ":", "", a:prefix, a:suffix,
+    \ a:groupBR)
+  let i = matchend(word, s:notslash . ":")
+  let wordBR = strpart(word, i)
+  let word = strpart(word, 0, i-1)
+  " Now, a:matchline =~ a:prefix . word . a:suffix
+  if wordBR != ini
+    let table = s:Resolve(ini, wordBR, "table")
+  else
+    " let table = "----------"
+    let table = ""
+    let d = 0
+    while d < 10
+      if tailBR =~ s:notslash . '\\' . d
+	" let table[d] = d
+	let table = table . d
+      else
+	let table = table . "-"
+      endif
+      let d = d + 1
+    endwhile
+  endif
+  let d = 9
+  while d
+    if table[d] != "-"
+      let backref = substitute(a:matchline, a:prefix.word.a:suffix,
+	\ '\'.table[d], "")
+	" Are there any other characters that should be escaped?
+      let backref = escape(backref, '*,:')
+      execute s:Ref(ini, d, "start", "len")
+      let ini = strpart(ini, 0, start) . backref . strpart(ini, start+len)
+      let tailBR = substitute(tailBR, s:notslash . '\zs\\' . d,
+	\ escape(backref, '\\'), 'g')
+    endif
+    let d = d-1
+  endwhile
+  if exists("b:match_debug")
+    if s:do_BR
+      let b:match_table = table
+      let b:match_word = word
+    else
+      let b:match_table = ""
+      let b:match_word = ""
+    endif
+  endif
+  return ini . ":" . tailBR
+endfun
+
+" Input a comma-separated list of groups with backrefs, such as
+"   a:groups = '\(foo\):end\1,\(bar\):end\1'
+" and return a comma-separated list of groups with backrefs replaced:
+"   return '\(foo\):end\(foo\),\(bar\):end\(bar\)'
+fun! s:ParseWords(groups)
+  let groups = substitute(a:groups.",", s:notslash.'\zs[,:]*,[,:]*', ',', 'g')
+  let groups = substitute(groups, s:notslash . '\zs:\{2,}', ':', 'g')
+  let parsed = ""
+  while groups =~ '[^,:]'
+    let i = matchend(groups, s:notslash . ':')
+    let j = matchend(groups, s:notslash . ',')
+    let ini = strpart(groups, 0, i-1)
+    let tail = strpart(groups, i, j-i-1) . ":"
+    let groups = strpart(groups, j)
+    let parsed = parsed . ini
+    let i = matchend(tail, s:notslash . ':')
+    while i != -1
+      " In 'if:else:endif', ini='if' and word='else' and then word='endif'.
+      let word = strpart(tail, 0, i-1)
+      let tail = strpart(tail, i)
+      let i = matchend(tail, s:notslash . ':')
+      let parsed = parsed . ":" . s:Resolve(ini, word, "word")
+    endwhile " Now, tail has been used up.
+    let parsed = parsed . ","
+  endwhile " groups =~ '[^,:]'
+  return parsed
+endfun
+
+" TODO I think this can be simplified and/or made more efficient.
+" TODO What should I do if a:start is out of range?
+" Return a regexp that matches all of a:string, such that
+" matchstr(a:string, regexp) represents the match for a:pat that starts
+" as close to a:start as possible, before being preferred to after, and
+" ends after a:start .
+" Usage:
+" let regexp = s:Wholematch(getline("."), 'foo\|bar', col(".")-1)
+" let i      = match(getline("."), regexp)
+" let j      = matchend(getline("."), regexp)
+" let match  = matchstr(getline("."), regexp)
+fun! s:Wholematch(string, pat, start)
+  let group = '\%(' . a:pat . '\)'
+  let prefix = (a:start ? '\(^.*\%<' . (a:start + 2) . 'c\)\zs' : '^')
+  let len = strlen(a:string)
+  let suffix = (a:start+1 < len ? '\(\%>'.(a:start+1).'c.*$\)\@=' : '$')
+  if a:string !~ prefix . group . suffix
+    let prefix = ''
+  endif
+  return prefix . group . suffix
+endfun
+
+" No extra arguments:  s:Ref(string, d) will
+" find the d'th occurrence of '\(' and return it, along with everything up
+" to and including the matching '\)'.
+" One argument:  s:Ref(string, d, "start") returns the index of the start
+" of the d'th '\(' and any other argument returns the length of the group.
+" Two arguments:  s:Ref(string, d, "foo", "bar") returns a string to be
+" executed, having the effect of
+"   :let foo = s:Ref(string, d, "start")
+"   :let bar = s:Ref(string, d, "len")
+fun! s:Ref(string, d, ...)
+  let len = strlen(a:string)
+  if a:d == 0
+    let start = 0
+  else
+    let cnt = a:d
+    let match = a:string
+    while cnt
+      let cnt = cnt - 1
+      let index = matchend(match, s:notslash . '\\(')
+      if index == -1
+	return ""
+      endif
+      let match = strpart(match, index)
+    endwhile
+    let start = len - strlen(match)
+    if a:0 == 1 && a:1 == "start"
+      return start - 2
+    endif
+    let cnt = 1
+    while cnt
+      let index = matchend(match, s:notslash . '\\(\|\\)') - 1
+      if index == -2
+	return ""
+      endif
+      " Increment if an open, decrement if a ')':
+      let cnt = cnt + (match[index]=="(" ? 1 : -1)  " ')'
+      " let cnt = stridx('0(', match[index]) + cnt
+      let match = strpart(match, index+1)
+    endwhile
+    let start = start - 2
+    let len = len - start - strlen(match)
+  endif
+  if a:0 == 1
+    return len
+  elseif a:0 == 2
+    return "let " . a:1 . "=" . start . "| let " . a:2 . "=" . len
+  else
+    return strpart(a:string, start, len)
+  endif
+endfun
+
+" Count the number of disjoint copies of pattern in string.
+" If the pattern is a literal string and contains no '0' or '1' characters
+" then s:Count(string, pattern, '0', '1') should be faster than
+" s:Count(string, pattern).
+fun! s:Count(string, pattern, ...)
+  let pat = escape(a:pattern, '\\')
+  if a:0 > 1
+    let foo = substitute(a:string, '[^'.a:pattern.']', "a:1", "g")
+    let foo = substitute(a:string, pat, a:2, "g")
+    let foo = substitute(foo, '[^' . a:2 . ']', "", "g")
+    return strlen(foo)
+  endif
+  let result = 0
+  let foo = a:string
+  let index = matchend(foo, pat)
+  while index != -1
+    let result = result + 1
+    let foo = strpart(foo, index)
+    let index = matchend(foo, pat)
+  endwhile
+  return result
+endfun
+
+" s:Resolve('\(a\)\(b\)', '\(c\)\2\1\1\2') should return table.word, where
+" word = '\(c\)\(b\)\(a\)\3\2' and table = '-32-------'.  That is, the first
+" '\1' in target is replaced by '\(a\)' in word, table[1] = 3, and this
+" indicates that all other instances of '\1' in target are to be replaced
+" by '\3'.  The hard part is dealing with nesting...
+" Note that ":" is an illegal character for source and target,
+" unless it is preceded by "\".
+fun! s:Resolve(source, target, output)
+  let word = a:target
+  let i = matchend(word, s:notslash . '\\\d') - 1
+  let table = "----------"
+  while i != -2 " There are back references to be replaced.
+    let d = word[i]
+    let backref = s:Ref(a:source, d)
+    " The idea is to replace '\d' with backref.  Before we do this,
+    " replace any \(\) groups in backref with :1, :2, ... if they
+    " correspond to the first, second, ... group already inserted
+    " into backref.  Later, replace :1 with \1 and so on.  The group
+    " number w+b within backref corresponds to the group number
+    " s within a:source.
+    " w = number of '\(' in word before the current one
+    let w = s:Count(
+    \ substitute(strpart(word, 0, i-1), '\\\\', '', 'g'), '\(', '1')
+    let b = 1 " number of the current '\(' in backref
+    let s = d " number of the current '\(' in a:source
+    while b <= s:Count(substitute(backref, '\\\\', '', 'g'), '\(', '1')
+    \ && s < 10
+      if table[s] == "-"
+	if w + b < 10
+	  " let table[s] = w + b
+	  let table = strpart(table, 0, s) . (w+b) . strpart(table, s+1)
+	endif
+	let b = b + 1
+	let s = s + 1
+      else
+	execute s:Ref(backref, b, "start", "len")
+	let ref = strpart(backref, start, len)
+	let backref = strpart(backref, 0, start) . ":". table[s]
+	\ . strpart(backref, start+len)
+	let s = s + s:Count(substitute(ref, '\\\\', '', 'g'), '\(', '1')
+      endif
+    endwhile
+    let word = strpart(word, 0, i-1) . backref . strpart(word, i+1)
+    let i = matchend(word, s:notslash . '\\\d') - 1
+  endwhile
+  let word = substitute(word, s:notslash . '\zs:', '\\', 'g')
+  if a:output == "table"
+    return table
+  elseif a:output == "word"
+    return word
+  else
+    return table . word
+  endif
+endfun
+
+" Assume a:comma = ",".  Then the format for a:patterns and a:1 is
+"   a:patterns = "<pat1>,<pat2>,..."
+"   a:1 = "<alt1>,<alt2>,..."
+" If <patn> is the first pattern that matches a:string then return <patn>
+" if no optional arguments are given; return <patn>,<altn> if a:1 is given.
+fun! s:Choose(patterns, string, comma, branch, prefix, suffix, ...)
+  let tail = (a:patterns =~ a:comma."$" ? a:patterns : a:patterns . a:comma)
+  let i = matchend(tail, s:notslash . a:comma)
+  if a:0
+    let alttail = (a:1 =~ a:comma."$" ? a:1 : a:1 . a:comma)
+    let j = matchend(alttail, s:notslash . a:comma)
+  endif
+  let current = strpart(tail, 0, i-1)
+  if a:branch == ""
+    let currpat = current
+  else
+    let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
+  endif
+  while a:string !~ a:prefix . currpat . a:suffix
+    let tail = strpart(tail, i)
+    let i = matchend(tail, s:notslash . a:comma)
+    if i == -1
+      return -1
+    endif
+    let current = strpart(tail, 0, i-1)
+    if a:branch == ""
+      let currpat = current
+    else
+      let currpat = substitute(current, s:notslash . a:branch, '\\|', 'g')
+    endif
+    if a:0
+      let alttail = strpart(alttail, j)
+      let j = matchend(alttail, s:notslash . a:comma)
+    endif
+  endwhile
+  if a:0
+    let current = current . a:comma . strpart(alttail, 0, j-1)
+  endif
+  return current
+endfun
+
+" Call this function to turn on debugging information.  Every time the main
+" script is run, buffer variables will be saved.  These can be used directly
+" or viewed using the menu items below.
+if !exists(":MatchDebug")
+  command! -nargs=0 MatchDebug call s:Match_debug()
+endif
+
+fun! s:Match_debug()
+  let b:match_debug = 1	" Save debugging information.
+  " pat = all of b:match_words with backrefs parsed
+  amenu &Matchit.&pat	:echo b:match_pat<CR>
+  " match = bit of text that is recognized as a match
+  amenu &Matchit.&match	:echo b:match_match<CR>
+  " curcol = cursor column of the start of the matching text
+  amenu &Matchit.&curcol	:echo b:match_col<CR>
+  " wholeBR = matching group, original version
+  amenu &Matchit.wh&oleBR	:echo b:match_wholeBR<CR>
+  " iniBR = 'if' piece, original version
+  amenu &Matchit.ini&BR	:echo b:match_iniBR<CR>
+  " ini = 'if' piece, with all backrefs resolved from match
+  amenu &Matchit.&ini	:echo b:match_ini<CR>
+  " tail = 'else\|endif' piece, with all backrefs resolved from match
+  amenu &Matchit.&tail	:echo b:match_tail<CR>
+  " fin = 'endif' piece, with all backrefs resolved from match
+  amenu &Matchit.&word	:echo b:match_word<CR>
+  " '\'.d in ini refers to the same thing as '\'.table[d] in word.
+  amenu &Matchit.t&able	:echo '0:' . b:match_table . ':9'<CR>
+endfun
+
+" Jump to the nearest unmatched "(" or "if" or "<tag>" if a:spflag == "bW"
+" or the nearest unmatched "</tag>" or "endif" or ")" if a:spflag == "W".
+" Return a "mark" for the original position, so that
+"   let m = MultiMatch("bW", "n") ... execute m
+" will return to the original position.  If there is a problem, do not
+" move the cursor and return "", unless a count is given, in which case
+" go up or down as many levels as possible and again return "".
+" TODO This relies on the same patterns as % matching.  It might be a good
+" idea to give it its own matching patterns.
+fun! s:MultiMatch(spflag, mode)
+  if !exists("b:match_words") || b:match_words == ""
+    return ""
+  end
+  let restore_options = (&ic ? "" : "no") . "ignorecase"
+  if exists("b:match_ignorecase")
+    let &ignorecase = b:match_ignorecase
+  endif
+  let startline = line(".")
+  let startcol = col(".")
+
+  " First step:  if not already done, set the script variables
+  "   s:do_BR	flag for whether there are backrefs
+  "   s:pat	parsed version of b:match_words
+  "   s:all	regexp based on s:pat and the default groups
+  " This part is copied and slightly modified from s:Match_wrapper().
+  let default = escape(&mps, '[$^.*~\\/?]') . (strlen(&mps) ? "," : "") .
+    \ '\/\*:\*\/,#if\%(def\)\=:#else\>:#elif\>:#endif\>'
+  " Allow b:match_words = "GetVimMatchWords()" .
+  if b:match_words =~ ":"
+    let match_words = b:match_words
+  else
+    execute "let match_words =" b:match_words
+  endif
+  if (match_words != s:last_words) || (&mps != s:last_mps) ||
+    \ exists("b:match_debug")
+    let s:last_words = match_words
+    let s:last_mps = &mps
+    if match_words !~ s:notslash . '\\\d'
+      let s:do_BR = 0
+      let s:pat = match_words
+    else
+      let s:do_BR = 1
+      let s:pat = s:ParseWords(match_words)
+    endif
+    let s:all = '\%(' . substitute(s:pat . (strlen(s:pat)?",":"") . default,
+      \	'[,:]\+','\\|','g') . '\)'
+    if exists("b:match_debug")
+      let b:match_pat = s:pat
+    endif
+  endif
+
+  " Second step:  figure out the patterns for searchpair()
+  " and save the screen, cursor position, and 'ignorecase'.
+  " - TODO:  A lot of this is copied from s:Match_wrapper().
+  " - maybe even more functionality should be split off
+  " - into separate functions!
+  let cdefault = (s:pat =~ '[^,]$' ? "," : "") . default
+  let open =  substitute(s:pat . cdefault,
+	\ s:notslash . '\zs:.\{-}' . s:notslash . ',', '\\),\\(', 'g')
+  let open =  '\(' . substitute(open, s:notslash . '\zs:.*$', '\\)', '')
+  let close = substitute(s:pat . cdefault,
+	\ s:notslash . '\zs,.\{-}' . s:notslash . ':', '\\),\\(', 'g')
+  let close = substitute(close, '^.\{-}' . s:notslash . ':', '\\(', '') . '\)'
+  if exists("b:match_skip")
+    let skip = b:match_skip
+  elseif exists("b:match_comment") " backwards compatibility and testing!
+    let skip = "r:" . b:match_comment
+  else
+    let skip = 's:comment\|string'
+  endif
+  let skip = s:ParseSkip(skip)
+  " let restore_cursor = line(".") . "G" . virtcol(".") . "|"
+  " normal! H
+  " let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
+  let restore_cursor = virtcol(".") . "|"
+  normal! g0
+  let restore_cursor = line(".") . "G" .  virtcol(".") . "|zs" . restore_cursor
+  normal! H
+  let restore_cursor = "normal!" . line(".") . "Gzt" . restore_cursor
+  execute restore_cursor
+
+  " Third step: call searchpair().
+  " Replace '\('--but not '\\('--with '\%(' and ',' with '\|'.
+  let openpat =  substitute(open, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
+  let openpat = substitute(openpat, ',', '\\|', 'g')
+  let closepat = substitute(close, '\(\\\@<!\(\\\\\)*\)\@<=\\(', '\\%(', 'g')
+  let closepat = substitute(closepat, ',', '\\|', 'g')
+  if skip =~ 'synID' && !(has("syntax") && exists("g:syntax_on"))
+    let skip = '0'
+  else
+    execute "if " . skip . "| let skip = '0' | endif"
+  endif
+  mark '
+  let level = v:count1
+  while level
+    if searchpair(openpat, '', closepat, a:spflag, skip) < 1
+      call s:CleanUp(restore_options, a:mode, startline, startcol)
+      return ""
+    endif
+    let level = level - 1
+  endwhile
+
+  " Restore options and return a string to restore the original position.
+  call s:CleanUp(restore_options, a:mode, startline, startcol)
+  return restore_cursor
+endfun
+
+" Search backwards for "if" or "while" or "<tag>" or ...
+" and return "endif" or "endwhile" or "</tag>" or ... .
+" For now, this uses b:match_words and the same script variables
+" as s:Match_wrapper() .  Later, it may get its own patterns,
+" either from a buffer variable or passed as arguments.
+" fun! s:Autocomplete()
+"   echo "autocomplete not yet implemented :-("
+"   if !exists("b:match_words") || b:match_words == ""
+"     return ""
+"   end
+"   let startpos = s:MultiMatch("bW")
+"
+"   if startpos == ""
+"     return ""
+"   endif
+"   " - TODO:  figure out whether 'if' or '<tag>' matched, and construct
+"   " - the appropriate closing.
+"   let matchline = getline(".")
+"   let curcol = col(".") - 1
+"   " - TODO:  Change the s:all argument if there is a new set of match pats.
+"   let regexp = s:Wholematch(matchline, s:all, curcol)
+"   let suf = strlen(matchline) - matchend(matchline, regexp)
+"   let prefix = (curcol ? '^.\{'  . curcol . '}\%(' : '^\%(')
+"   let suffix = (suf ? '\).\{' . suf . '}$'  : '\)$')
+"   " Reconstruct the version with unresolved backrefs.
+"   let patBR = substitute(b:match_words.',', '[,:]*,[,:]*', ',', 'g')
+"   let patBR = substitute(patBR, ':\{2,}', ':', "g")
+"   " Now, set group and groupBR to the matching group: 'if:endif' or
+"   " 'while:endwhile' or whatever.
+"   let group = s:Choose(s:pat, matchline, ",", ":", prefix, suffix, patBR)
+"   let i = matchend(group, s:notslash . ",")
+"   let groupBR = strpart(group, i)
+"   let group = strpart(group, 0, i-1)
+"   " Now, matchline =~ prefix . substitute(group,':','\|','g') . suffix
+"   if s:do_BR
+"     let group = s:InsertRefs(groupBR, prefix, group, suffix, matchline)
+"   endif
+" " let g:group = group
+"
+"   " - TODO:  Construct the closing from group.
+"   let fake = "end" . expand("<cword>")
+"   execute startpos
+"   return fake
+" endfun
+
+" Close all open structures.  "Get the heck out of here!"
+" fun! s:Gthhoh()
+"   let close = s:Autocomplete()
+"   while strlen(close)
+"     put=close
+"     let close = s:Autocomplete()
+"   endwhile
+" endfun
+
+" Parse special strings as typical skip arguments for searchpair():
+"   s:foo becomes (current syntax item) =~ foo
+"   S:foo becomes (current syntax item) !~ foo
+"   r:foo becomes (line before cursor) =~ foo
+"   R:foo becomes (line before cursor) !~ foo
+fun! s:ParseSkip(str)
+  let skip = a:str
+  if skip[1] == ":"
+    if skip[0] == "s"
+      let skip = "synIDattr(synID(line('.'),col('.'),1),'name') =~? '" .
+	\ strpart(skip,2) . "'"
+    elseif skip[0] == "S"
+      let skip = "synIDattr(synID(line('.'),col('.'),1),'name') !~? '" .
+	\ strpart(skip,2) . "'"
+    elseif skip[0] == "r"
+      let skip = "strpart(getline('.'),0,col('.'))=~'" . strpart(skip,2). "'"
+    elseif skip[0] == "R"
+      let skip = "strpart(getline('.'),0,col('.'))!~'" . strpart(skip,2). "'"
+    endif
+  endif
+  return skip
+endfun
+
+let &cpo = s:save_cpo
+
+" vim:sts=2:sw=2:
diff -urN vim71/runtime/plugin/taglist.vim vim71_ada/runtime/plugin/taglist.vim
--- vim71/runtime/plugin/taglist.vim	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/plugin/taglist.vim	2008-01-16 16:37:03.000000000 +0100
@@ -0,0 +1,4524 @@
+" File: taglist.vim
+" Author: Yegappan Lakshmanan (yegappan AT yahoo DOT com)
+" Version: 4.3
+" Last Modified: February 18, 2007
+" Copyright: Copyright (C) 2002-2006 Yegappan Lakshmanan
+"            Permission is hereby granted to use and distribute this code,
+"            with or without modifications, provided that this copyright
+"            notice is copied with it. Like anything else that's free,
+"            taglist.vim is provided *as is* and comes with no warranty of any
+"            kind, either expressed or implied. In no event will the copyright
+"            holder be liable for any damamges resulting from the use of this
+"            software.
+"
+" The "Tag List" plugin is a source code browser plugin for Vim and provides
+" an overview of the structure of the programming language files and allows
+" you to efficiently browse through source code files for different
+" programming languages.  You can visit the taglist plugin home page for more
+" information:
+"
+"       http://vim-taglist.sourceforge.net
+"
+" You can subscribe to the taglist mailing list to post your questions
+" or suggestions for improvement or to report bugs. Visit the following
+" page for subscribing to the mailing list:
+"
+"       http://groups.yahoo.com/group/taglist/
+"
+" For more information about using this plugin, after installing the
+" taglist plugin, use the ":help taglist" command.
+"
+" Installation
+" ------------
+" 1. Download the taglist.zip file and unzip the files to the $HOME/.vim
+"    or the $HOME/vimfiles or the $VIM/vimfiles directory. This should
+"    unzip the following two files (the directory structure should be
+"    preserved):
+"
+"       plugin/taglist.vim - main taglist plugin file
+"       doc/taglist.txt    - documentation (help) file
+"
+"    Refer to the 'add-plugin', 'add-global-plugin' and 'runtimepath'
+"    Vim help pages for more details about installing Vim plugins.
+" 2. Change to the $HOME/.vim/doc or $HOME/vimfiles/doc or
+"    $VIM/vimfiles/doc directory, start Vim and run the ":helptags ."
+"    command to process the taglist help file.
+" 3. If the exuberant ctags utility is not present in your PATH, then set the
+"    Tlist_Ctags_Cmd variable to point to the location of the exuberant ctags
+"    utility (not to the directory) in the .vimrc file.
+" 4. If you are running a terminal/console version of Vim and the
+"    terminal doesn't support changing the window width then set the
+"    'Tlist_Inc_Winwidth' variable to 0 in the .vimrc file.
+" 5. Restart Vim.
+" 6. You can now use the ":TlistToggle" command to open/close the taglist
+"    window. You can use the ":help taglist" command to get more
+"    information about using the taglist plugin.
+"
+" ****************** Do not modify after this line ************************
+
+" Line continuation used here
+let s:cpo_save = &cpo
+set cpo&vim
+
+if !exists('loaded_taglist')
+    " First time loading the taglist plugin
+    "
+    " To speed up the loading of Vim, the taglist plugin uses autoload
+    " mechanism to load the taglist functions.
+    " Only define the configuration variables, user commands and some
+    " auto-commands and finish sourcing the file
+
+    " The taglist plugin requires the built-in Vim system() function. If this
+    " function is not available, then don't load the plugin.
+    if !exists('*system')
+        echomsg 'Taglist: Vim system() built-in function is not available. ' .
+                    \ 'Plugin is not loaded.'
+        let loaded_taglist = 'no'
+        let &cpo = s:cpo_save
+        finish
+    endif
+
+    " Location of the exuberant ctags tool
+    if !exists('Tlist_Ctags_Cmd')
+        if executable('exuberant-ctags')
+            " On Debian Linux, exuberant ctags is installed
+            " as exuberant-ctags
+            let Tlist_Ctags_Cmd = 'exuberant-ctags'
+        elseif executable(' exctags')
+            " On Free-BSD, exuberant ctags is installed as exctags
+            let Tlist_Ctags_ Cmd = 'exctags'
+        elseif executable('ctags')
+            let Tlist_Ctags_Cmd = 'ctags'
+        elseif executable('ctags.exe')
+            let Tlist_Ctags_Cmd = 'ctags.exe'
+        elseif executable('tags')
+            let Tlist_Ctags_Cmd = 'tags'
+        else
+        "    echomsg 'Taglist: Exuberant ctags (http://ctags.sf.net) ' .
+        "                \ 'not found in PATH. Plugin is not loaded.'
+            " Skip loading the plugin
+            let loaded_taglist = 'no'
+            let &cpo = s:cpo_save
+            finish
+        endif
+    endif
+
+
+    " Automatically open the taglist window on Vim startup
+    if !exists('Tlist_Auto_Open')
+        let Tlist_Auto_Open = 0
+    endif
+
+    " When the taglist window is toggle opened, move the cursor to the
+    " taglist window
+    if !exists('Tlist_GainFocus_On_ToggleOpen')
+        let Tlist_GainFocus_On_ToggleOpen = 0
+    endif
+
+    " Process files even when the taglist window is not open
+    if !exists('Tlist_Process_File_Always')
+        let Tlist_Process_File_Always = 0
+    endif
+
+    if !exists('Tlist_Show_Menu')
+        let Tlist_Show_Menu = 0
+    endif
+
+    " Tag listing sort type - 'name' or 'order'
+    if !exists('Tlist_Sort_Type')
+        let Tlist_Sort_Type = 'order'
+    endif
+
+    " Tag listing window split (horizontal/vertical) control
+    if !exists('Tlist_Use_Horiz_Window')
+        let Tlist_Use_Horiz_Window = 0
+    endif
+
+    " Open the vertically split taglist window on the left or on the right
+    " side.  This setting is relevant only if Tlist_Use_Horiz_Window is set to
+    " zero (i.e.  only for vertically split windows)
+    if !exists('Tlist_Use_Right_Window')
+        let Tlist_Use_Right_Window = 0
+    endif
+
+    " Increase Vim window width to display vertically split taglist window.
+    " For MS-Windows version of Vim running in a MS-DOS window, this must be
+    " set to 0 otherwise the system may hang due to a Vim limitation.
+    if !exists('Tlist_Inc_Winwidth')
+        if (has('win16') || has('win95')) && !has('gui_running')
+            let Tlist_Inc_Winwidth = 0
+        else
+            let Tlist_Inc_Winwidth = 1
+        endif
+    endif
+
+    " Vertically split taglist window width setting
+    if !exists('Tlist_WinWidth')
+        let Tlist_WinWidth = 30
+    endif
+
+    " Horizontally split taglist window height setting
+    if !exists('Tlist_WinHeight')
+        let Tlist_WinHeight = 10
+    endif
+
+    " Display tag prototypes or tag names in the taglist window
+    if !exists('Tlist_Display_Prototype')
+        let Tlist_Display_Prototype = 0
+    endif
+
+    " Display tag scopes in the taglist window
+    if !exists('Tlist_Display_Tag_Scope')
+        let Tlist_Display_Tag_Scope = 1
+    endif
+
+    " Use single left mouse click to jump to a tag. By default this is disabled.
+    " Only double click using the mouse will be processed.
+    if !exists('Tlist_Use_SingleClick')
+        let Tlist_Use_SingleClick = 0
+    endif
+
+    " Control whether additional help is displayed as part of the taglist or
+    " not.  Also, controls whether empty lines are used to separate the tag
+    " tree.
+    if !exists('Tlist_Compact_Format')
+        let Tlist_Compact_Format = 0
+    endif
+
+    " Exit Vim if only the taglist window is currently open. By default, this is
+    " set to zero.
+    if !exists('Tlist_Exit_OnlyWindow')
+        let Tlist_Exit_OnlyWindow = 0
+    endif
+
+    " Automatically close the folds for the non-active files in the taglist
+    " window
+    if !exists('Tlist_File_Fold_Auto_Close')
+        let Tlist_File_Fold_Auto_Close = 0
+    endif
+
+    " Close the taglist window when a tag is selected
+    if !exists('Tlist_Close_On_Select')
+        let Tlist_Close_On_Select = 0
+    endif
+
+    " Automatically update the taglist window to display tags for newly
+    " edited files
+    if !exists('Tlist_Auto_Update')
+        let Tlist_Auto_Update = 1
+    endif
+
+    " Automatically highlight the current tag
+    if !exists('Tlist_Auto_Highlight_Tag')
+        let Tlist_Auto_Highlight_Tag = 1
+    endif
+    
+    " Automatically highlight the current tag on entering a buffer
+    if !exists('Tlist_Highlight_Tag_On_BufEnter')
+        let Tlist_Highlight_Tag_On_BufEnter = 1
+    endif
+
+    " Enable fold column to display the folding for the tag tree
+    if !exists('Tlist_Enable_Fold_Column')
+        let Tlist_Enable_Fold_Column = 1
+    endif
+
+    " Display the tags for only one file in the taglist window
+    if !exists('Tlist_Show_One_File')
+        let Tlist_Show_One_File = 0
+    endif
+
+    if !exists('Tlist_Max_Submenu_Items')
+        let Tlist_Max_Submenu_Items = 20
+    endif
+
+    if !exists('Tlist_Max_Tag_Length')
+        let Tlist_Max_Tag_Length = 10
+    endif
+
+    " Do not change the name of the taglist title variable. The winmanager
+    " plugin relies on this name to determine the title for the taglist
+    " plugin.
+    let TagList_title = "__Tag_List__"
+
+    " Taglist debug messages
+    let s:tlist_msg = ''
+
+    " Define the taglist autocommand to automatically open the taglist window
+    " on Vim startup
+    if g:Tlist_Auto_Open
+        autocmd VimEnter * nested call s:Tlist_Window_Check_Auto_Open()
+    endif
+
+    " Refresh the taglist
+    if g:Tlist_Process_File_Always
+        autocmd BufEnter * call s:Tlist_Refresh()
+    endif
+
+    if g:Tlist_Show_Menu
+        autocmd GUIEnter * call s:Tlist_Menu_Init()
+    endif
+
+    " When the taglist buffer is created when loading a Vim session file,
+    " the taglist buffer needs to be initialized. The BufFilePost event
+    " is used to handle this case.
+    autocmd BufFilePost __Tag_List__ call s:Tlist_Vim_Session_Load()
+
+    " Define the user commands to manage the taglist window
+    command! -nargs=0 -bar TlistToggle call s:Tlist_Window_Toggle()
+    command! -nargs=0 -bar TlistOpen call s:Tlist_Window_Open()
+    " For backwards compatiblity define the Tlist command
+    command! -nargs=0 -bar Tlist TlistToggle
+    command! -nargs=+ -complete=file TlistAddFiles
+                \  call s:Tlist_Add_Files(<f-args>)
+    command! -nargs=+ -complete=dir TlistAddFilesRecursive
+                \ call s:Tlist_Add_Files_Recursive(<f-args>)
+    command! -nargs=0 -bar TlistClose call s:Tlist_Window_Close()
+    command! -nargs=0 -bar TlistUpdate call s:Tlist_Update_Current_File()
+    command! -nargs=0 -bar TlistHighlightTag call s:Tlist_Window_Highlight_Tag(
+                        \ fnamemodify(bufname('%'), ':p'), line('.'), 2, 1)
+    " For backwards compatiblity define the TlistSync command
+    command! -nargs=0 -bar TlistSync TlistHighlightTag
+    command! -nargs=* -complete=buffer TlistShowPrototype
+                \ echo Tlist_Get_Tag_Prototype_By_Line(<f-args>)
+    command! -nargs=* -complete=buffer TlistShowTag
+                \ echo Tlist_Get_Tagname_By_Line(<f-args>)
+    command! -nargs=* -complete=file TlistSessionLoad
+                \ call s:Tlist_Session_Load(<q-args>)
+    command! -nargs=* -complete=file TlistSessionSave
+                \ call s:Tlist_Session_Save(<q-args>)
+    command! -bar TlistLock let Tlist_Auto_Update=0
+    command! -bar TlistUnlock let Tlist_Auto_Update=1
+
+    " Commands for enabling/disabling debug and to display debug messages
+    command! -nargs=? -complete=file -bar TlistDebug
+                \ call s:Tlist_Debug_Enable(<q-args>)
+    command! -nargs=0 -bar TlistUndebug  call s:Tlist_Debug_Disable()
+    command! -nargs=0 -bar TlistMessages call s:Tlist_Debug_Show()
+
+    " Define autocommands to autoload the taglist plugin when needed.
+
+    " Trick to get the current script ID
+    map <SID>xx <SID>xx
+    let s:tlist_sid = substitute(maparg('<SID>xx'), '<SNR>\(\d\+_\)xx$',
+                                \ '\1', '')
+    unmap <SID>xx
+
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Window_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined *' . s:tlist_sid . 'Tlist_Menu_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined Tlist_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+    exe 'autocmd FuncUndefined TagList_* source ' .
+                \ escape(expand('<sfile>'), ' ')
+
+    let loaded_taglist = 'fast_load_done'
+
+    if g:Tlist_Show_Menu && has('gui_running')
+        call s:Tlist_Menu_Init()
+    endif
+
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+if !exists('s:tlist_sid')
+    " Two or more versions of taglist plugin are installed. Don't
+    " load this version of the plugin.
+    finish
+endif
+
+unlet! s:tlist_sid
+
+if loaded_taglist != 'fast_load_done'
+    " restore 'cpo'
+    let &cpo = s:cpo_save
+    finish
+endif
+
+" Taglist plugin functionality is available
+let loaded_taglist = 'available'
+
+"------------------- end of user configurable options --------------------
+
+" Default language specific settings for supported file types and tag types
+"
+" Variable name format:
+"
+"       s:tlist_def_{vim_ftype}_settings
+" 
+" vim_ftype - Filetype detected by Vim
+"
+" Value format:
+"
+"       <ctags_ftype>;<flag>:<name>;<flag>:<name>;...
+"
+" ctags_ftype - File type supported by exuberant ctags
+" flag        - Flag supported by exuberant ctags to generate a tag type
+" name        - Name of the tag type used in the taglist window to display the
+"               tags of this type
+"
+
+" Ada language
+let s:tlist_def_ada_settings = 'ada;' .
+    \ 'P:package spec;' .
+    \ 'p:package body;' .
+    \ 'T:type spec;' .
+    \ 't:type;' .
+    \ 'U:subtype spec;' .
+    \ 'u:subtype;' .
+    \ 'c:component;' .
+    \ 'l:literal;' .
+    \ 'V:variable spec;' .
+    \ 'v:variable;' .
+    \ 'f:formal;' .
+    \ 'n:constant;' .
+    \ 'x:exception;' .
+    \ 'R:subprogram spec;' .
+    \ 'r:subprogram body;' .
+    \ 'K:task spec;' .
+    \ 'k:task body;' .
+    \ 'O:protected spec;' .
+    \ 'o:protected body;' .
+    \ 'E:entry spec;' .
+    \ 'e:entry body;' .
+    \ 'b:label;' .
+    \ 'i:identifier;' .
+    \ 'a:autovar;' .
+    \ 'y:annon'
+
+" assembly language
+let s:tlist_def_asm_settings = 'asm;d:define;l:label;m:macro;t:type'
+
+" aspperl language
+let s:tlist_def_aspperl_settings = 'asp;f:function;s:sub;v:variable'
+
+" aspvbs language
+let s:tlist_def_aspvbs_settings = 'asp;f:function;s:sub;v:variable'
+
+" awk language
+let s:tlist_def_awk_settings = 'awk;f:function'
+
+" beta language
+let s:tlist_def_beta_settings = 'beta;f:fragment;s:slot;v:pattern'
+
+" c language
+let s:tlist_def_c_settings = 'c;d:macro;g:enum;s:struct;u:union;t:typedef;' .
+                           \ 'v:variable;f:function'
+
+" c++ language
+let s:tlist_def_cpp_settings = 'c++;n:namespace;v:variable;d:macro;t:typedef;' .
+                             \ 'c:class;g:enum;s:struct;u:union;f:function'
+
+" c# language
+let s:tlist_def_cs_settings = 'c#;d:macro;t:typedef;n:namespace;c:class;' .
+                             \ 'E:event;g:enum;s:struct;i:interface;' .
+                             \ 'p:properties;m:method'
+
+" cobol language
+let s:tlist_def_cobol_settings = 'cobol;d:data;f:file;g:group;p:paragraph;' .
+                               \ 'P:program;s:section'
+
+" eiffel language
+let s:tlist_def_eiffel_settings = 'eiffel;c:class;f:feature'
+
+" erlang language
+let s:tlist_def_erlang_settings = 'erlang;d:macro;r:record;m:module;f:function'
+
+" expect (same as tcl) language
+let s:tlist_def_expect_settings = 'tcl;c:class;f:method;p:procedure'
+
+" fortran language
+let s:tlist_def_fortran_settings = 'fortran;p:program;b:block data;' .
+                    \ 'c:common;e:entry;i:interface;k:type;l:label;m:module;' .
+                    \ 'n:namelist;t:derived;v:variable;f:function;s:subroutine'
+
+" HTML language
+let s:tlist_def_html_settings = 'html;a:anchor;f:javascript function'
+
+" java language
+let s:tlist_def_java_settings = 'java;p:package;c:class;i:interface;' .
+                              \ 'f:field;m:method'
+
+" javascript language
+let s:tlist_def_javascript_settings = 'javascript;f:function'
+
+" lisp language
+let s:tlist_def_lisp_settings = 'lisp;f:function'
+
+" lua language
+let s:tlist_def_lua_settings = 'lua;f:function'
+
+" makefiles
+let s:tlist_def_make_settings = 'make;m:macro'
+
+" pascal language
+let s:tlist_def_pascal_settings = 'pascal;f:function;p:procedure'
+
+" perl language
+let s:tlist_def_perl_settings = 'perl;c:constant;l:label;p:package;s:subroutine'
+
+" php language
+let s:tlist_def_php_settings = 'php;c:class;d:constant;v:variable;f:function'
+
+" python language
+let s:tlist_def_python_settings = 'python;c:class;m:member;f:function'
+
+" rexx language
+let s:tlist_def_rexx_settings = 'rexx;s:subroutine'
+
+" ruby language
+let s:tlist_def_ruby_settings = 'ruby;c:class;f:method;F:function;' .
+                              \ 'm:singleton method'
+
+" scheme language
+let s:tlist_def_scheme_settings = 'scheme;s:set;f:function'
+
+" shell language
+let s:tlist_def_sh_settings = 'sh;f:function'
+
+" C shell language
+let s:tlist_def_csh_settings = 'sh;f:function'
+
+" Z shell language
+let s:tlist_def_zsh_settings = 'sh;f:function'
+
+" slang language
+let s:tlist_def_slang_settings = 'slang;n:namespace;f:function'
+
+" sml language
+let s:tlist_def_sml_settings = 'sml;e:exception;c:functor;s:signature;' .
+                             \ 'r:structure;t:type;v:value;f:function'
+
+" sql language
+let s:tlist_def_sql_settings = 'sql;c:cursor;F:field;P:package;r:record;' .
+            \ 's:subtype;t:table;T:trigger;v:variable;f:function;p:procedure'
+
+" tcl language
+let s:tlist_def_tcl_settings = 'tcl;c:class;f:method;m:method;p:procedure'
+
+" vera language
+let s:tlist_def_vera_settings = 'vera;c:class;d:macro;e:enumerator;' .
+                                \ 'f:function;g:enum;m:member;p:program;' .
+                                \ 'P:prototype;t:task;T:typedef;v:variable;' .
+                                \ 'x:externvar'
+
+"verilog language
+let s:tlist_def_verilog_settings = 'verilog;m:module;c:constant;P:parameter;' .
+            \ 'e:event;r:register;t:task;w:write;p:port;v:variable;f:function'
+
+" vim language
+let s:tlist_def_vim_settings = 'vim;a:autocmds;v:variable;f:function'
+
+" yacc language
+let s:tlist_def_yacc_settings = 'yacc;l:label'
+
+"------------------- end of language specific options --------------------
+
+" Vim window size is changed by the taglist plugin or not
+let s:tlist_winsize_chgd = -1
+" Taglist window is maximized or not
+let s:tlist_win_maximized = 0
+" Name of files in the taglist
+let s:tlist_file_names=''
+" Number of files in the taglist
+let s:tlist_file_count = 0
+" Number of filetypes supported by taglist
+let s:tlist_ftype_count = 0
+" Is taglist part of other plugins like winmanager or cream?
+let s:tlist_app_name = "none"
+" Are we displaying brief help text
+let s:tlist_brief_help = 1
+" List of files removed on user request
+let s:tlist_removed_flist = ""
+" Index of current file displayed in the taglist window
+let s:tlist_cur_file_idx = -1
+" Taglist menu is empty or not
+let s:tlist_menu_empty = 1
+
+" An autocommand is used to refresh the taglist window when entering any
+" buffer. We don't want to refresh the taglist window if we are entering the
+" file window from one of the taglist functions. The 'Tlist_Skip_Refresh'
+" variable is used to skip the refresh of the taglist window and is set
+" and cleared appropriately.
+let s:Tlist_Skip_Refresh = 0
+
+" Tlist_Window_Display_Help()
+function! s:Tlist_Window_Display_Help()
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    if s:tlist_brief_help
+        " Add the brief help
+        call append(0, '" Press <F1> to display help text')
+    else
+        " Add the extensive help
+        call append(0, '" <enter> : Jump to tag definition')
+        call append(1, '" o : Jump to tag definition in new window')
+        call append(2, '" p : Preview the tag definition')
+        call append(3, '" <space> : Display tag prototype')
+        call append(4, '" u : Update tag list')
+        call append(5, '" s : Select sort field')
+        call append(6, '" d : Remove file from taglist')
+        call append(7, '" x : Zoom-out/Zoom-in taglist window')
+        call append(8, '" + : Open a fold')
+        call append(9, '" - : Close a fold')
+        call append(10, '" * : Open all folds')
+        call append(11, '" = : Close all folds')
+        call append(12, '" [[ : Move to the start of previous file')
+        call append(13, '" ]] : Move to the start of next file')
+        call append(14, '" q : Close the taglist window')
+        call append(15, '" <F1> : Remove help text')
+    endif
+endfunction
+
+" Tlist_Window_Toggle_Help_Text()
+" Toggle taglist plugin help text between the full version and the brief
+" version
+function! s:Tlist_Window_Toggle_Help_Text()
+    if g:Tlist_Compact_Format
+        " In compact display mode, do not display help
+        return
+    endif
+
+    " Include the empty line displayed after the help text
+    let brief_help_size = 1
+    let full_help_size = 16
+
+    setlocal modifiable
+
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Remove the currently highlighted tag. Otherwise, the help text
+    " might be highlighted by mistake
+    match none
+
+    " Toggle between brief and full help text
+    if s:tlist_brief_help
+        let s:tlist_brief_help = 0
+
+        " Remove the previous help
+        exe '1,' . brief_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 1, full_help_size - brief_help_size)
+    else
+        let s:tlist_brief_help = 1
+
+        " Remove the previous help
+        exe '1,' . full_help_size . ' delete _'
+
+        " Adjust the start/end line numbers for the files
+        call s:Tlist_Window_Update_Line_Offsets(0, 0, full_help_size - brief_help_size)
+    endif
+
+    call s:Tlist_Window_Display_Help()
+
+    " Restore the report option
+    let &report = old_report
+
+    setlocal nomodifiable
+endfunction
+
+" Taglist debug support
+let s:tlist_debug = 0
+
+" File for storing the debug messages
+let s:tlist_debug_file = ''
+
+" Tlist_Debug_Enable
+" Enable logging of taglist debug messages.
+function! s:Tlist_Debug_Enable(...)
+    let s:tlist_debug = 1
+
+    " Check whether a valid file name is supplied.
+    if a:1 != ''
+        let s:tlist_debug_file = fnamemodify(a:1, ':p')
+
+        " Empty the log file
+        exe 'redir! > ' . s:tlist_debug_file
+        redir END
+
+        " Check whether the log file is present/created
+        if !filewritable(s:tlist_debug_file)
+            call s:Tlist_Warning_Msg('Taglist: Unable to create log file '
+                        \ . s:tlist_debug_file)
+            let s:tlist_debug_file = ''
+        endif
+    endif
+endfunction
+
+" Tlist_Debug_Disable
+" Disable logging of taglist debug messages.
+function! s:Tlist_Debug_Disable(...)
+    let s:tlist_debug = 0
+    let s:tlist_debug_file = ''
+endfunction
+
+" Tlist_Debug_Show
+" Display the taglist debug messages in a new window
+function! s:Tlist_Debug_Show()
+    if s:tlist_msg == ''
+        call s:Tlist_Warning_Msg('Taglist: No debug messages')
+        return
+    endif
+
+    " Open a new window to display the taglist debug messages
+    new taglist_debug.txt
+    " Delete all the lines (if the buffer already exists)
+    silent! %delete _
+    " Add the messages
+    silent! put =s:tlist_msg
+    " Move the cursor to the first line
+    normal! gg
+endfunction
+
+" Tlist_Log_Msg
+" Log the supplied debug message along with the time
+function! s:Tlist_Log_Msg(msg)
+    if s:tlist_debug
+        if s:tlist_debug_file != ''
+            exe 'redir >> ' . s:tlist_debug_file
+            silent echon strftime('%H:%M:%S') . ': ' . a:msg . "\n"
+            redir END
+        else
+            " Log the message into a variable
+            " Retain only the last 3000 characters
+            let len = strlen(s:tlist_msg)
+            if len > 3000
+                let s:tlist_msg = strpart(s:tlist_msg, len - 3000)
+            endif
+            let s:tlist_msg = s:tlist_msg . strftime('%H:%M:%S') . ': ' . 
+                        \ a:msg . "\n"
+        endif
+    endif
+endfunction
+
+" Tlist_Warning_Msg()
+" Display a message using WarningMsg highlight group
+function! s:Tlist_Warning_Msg(msg)
+    echohl WarningMsg
+    echomsg a:msg
+    echohl None
+endfunction
+
+" Last returned file index for file name lookup.
+" Used to speed up file lookup
+let s:tlist_file_name_idx_cache = -1
+
+" Tlist_Get_File_Index()
+" Return the index of the specified filename
+function! s:Tlist_Get_File_Index(fname)
+    if s:tlist_file_count == 0 || a:fname == ''
+        return -1
+    endif
+
+    " If the new filename is same as the last accessed filename, then
+    " return that index
+    if s:tlist_file_name_idx_cache != -1 &&
+                \ s:tlist_file_name_idx_cache < s:tlist_file_count
+        if s:tlist_{s:tlist_file_name_idx_cache}_filename == a:fname
+            " Same as the last accessed file
+            return s:tlist_file_name_idx_cache
+        endif
+    endif
+
+    " First, check whether the filename is present
+    let s_fname = a:fname . "\n"
+    let i = stridx(s:tlist_file_names, s_fname)
+    if i == -1
+        let s:tlist_file_name_idx_cache = -1
+        return -1
+    endif
+
+    " Second, compute the file name index
+    let nl_txt = substitute(strpart(s:tlist_file_names, 0, i), "[^\n]", '', 'g')
+    let s:tlist_file_name_idx_cache = strlen(nl_txt)
+    return s:tlist_file_name_idx_cache
+endfunction
+
+" Last returned file index for line number lookup.
+" Used to speed up file lookup
+let s:tlist_file_lnum_idx_cache = -1
+
+" Tlist_Window_Get_File_Index_By_Linenum()
+" Return the index of the filename present in the specified line number
+" Line number refers to the line number in the taglist window
+function! s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    call s:Tlist_Log_Msg('Tlist_Window_Get_File_Index_By_Linenum (' . a:lnum . ')')
+
+    " First try to see whether the new line number is within the range
+    " of the last returned file
+    if s:tlist_file_lnum_idx_cache != -1 &&
+                \ s:tlist_file_lnum_idx_cache < s:tlist_file_count
+        if a:lnum >= s:tlist_{s:tlist_file_lnum_idx_cache}_start &&
+                    \ a:lnum <= s:tlist_{s:tlist_file_lnum_idx_cache}_end
+            return s:tlist_file_lnum_idx_cache
+        endif
+    endif
+
+    let fidx = -1
+
+    if g:Tlist_Show_One_File
+        " Displaying only one file in the taglist window. Check whether
+        " the line is within the tags displayed for that file
+        if s:tlist_cur_file_idx != -1
+            if a:lnum >= s:tlist_{s:tlist_cur_file_idx}_start
+                        \ && a:lnum <= s:tlist_{s:tlist_cur_file_idx}_end
+                let fidx = s:tlist_cur_file_idx
+            endif
+
+        endif
+    else
+        " Do a binary search in the taglist
+        let left = 0
+        let right = s:tlist_file_count - 1
+
+        while left < right
+            let mid = (left + right) / 2
+
+            if a:lnum >= s:tlist_{mid}_start && a:lnum <= s:tlist_{mid}_end
+                let s:tlist_file_lnum_idx_cache = mid
+                return mid
+            endif
+
+            if a:lnum < s:tlist_{mid}_start
+                let right = mid - 1
+            else
+                let left = mid + 1
+            endif
+        endwhile
+
+        if left >= 0 && left < s:tlist_file_count
+                    \ && a:lnum >= s:tlist_{left}_start
+                    \ && a:lnum <= s:tlist_{left}_end
+            let fidx = left
+        endif
+    endif
+
+    let s:tlist_file_lnum_idx_cache = fidx
+
+    return fidx
+endfunction
+
+" Tlist_Exe_Cmd_No_Acmds
+" Execute the specified Ex command after disabling autocommands
+function! s:Tlist_Exe_Cmd_No_Acmds(cmd)
+    let old_eventignore = &eventignore
+    set eventignore=all
+    exe a:cmd
+    let &eventignore = old_eventignore
+endfunction
+
+" Tlist_Skip_File()
+" Check whether tag listing is supported for the specified file
+function! s:Tlist_Skip_File(filename, ftype)
+    " Skip buffers with no names and buffers with filetype not set
+    if a:filename == '' || a:ftype == ''
+        return 1
+    endif
+
+    " Skip files which are not supported by exuberant ctags
+    " First check whether default settings for this filetype are available.
+    " If it is not available, then check whether user specified settings are
+    " available. If both are not available, then don't list the tags for this
+    " filetype
+    let var = 's:tlist_def_' . a:ftype . '_settings'
+    if !exists(var)
+        let var = 'g:tlist_' . a:ftype . '_settings'
+        if !exists(var)
+            return 1
+        endif
+    endif
+
+    " Skip files which are not readable or files which are not yet stored
+    " to the disk
+    if !filereadable(a:filename)
+        return 1
+    endif
+
+    return 0
+endfunction
+
+" Tlist_User_Removed_File
+" Returns 1 if a file is removed by a user from the taglist
+function! s:Tlist_User_Removed_File(filename)
+    return stridx(s:tlist_removed_flist, a:filename . "\n") != -1
+endfunction
+
+" Tlist_Update_Remove_List
+" Update the list of user removed files from the taglist
+" add == 1, add the file to the removed list
+" add == 0, delete the file from the removed list
+function! s:Tlist_Update_Remove_List(filename, add)
+    if a:add
+        let s:tlist_removed_flist = s:tlist_removed_flist . a:filename . "\n"
+    else
+        let idx = stridx(s:tlist_removed_flist, a:filename . "\n")
+        let text_before = strpart(s:tlist_removed_flist, 0, idx)
+        let rem_text = strpart(s:tlist_removed_flist, idx)
+        let next_idx = stridx(rem_text, "\n")
+        let text_after = strpart(rem_text, next_idx + 1)
+
+        let s:tlist_removed_flist = text_before . text_after
+    endif
+endfunction
+
+" Tlist_FileType_Init
+" Initialize the ctags arguments and tag variable for the specified
+" file type
+function! s:Tlist_FileType_Init(ftype)
+    call s:Tlist_Log_Msg('Tlist_FileType_Init (' . a:ftype . ')')
+    " If the user didn't specify any settings, then use the default
+    " ctags args. Otherwise, use the settings specified by the user
+    let var = 'g:tlist_' . a:ftype . '_settings'
+    if exists(var)
+        " User specified ctags arguments
+        let settings = {var} . ';'
+    else
+        " Default ctags arguments
+        let var = 's:tlist_def_' . a:ftype . '_settings'
+        if !exists(var)
+            " No default settings for this file type. This filetype is
+            " not supported
+            return 0
+        endif
+        let settings = s:tlist_def_{a:ftype}_settings . ';'
+    endif
+
+    let msg = 'Taglist: Invalid ctags option setting - ' . settings
+
+    " Format of the option that specifies the filetype and ctags arugments:
+    "
+    "       <language_name>;flag1:name1;flag2:name2;flag3:name3
+    "
+
+    " Extract the file type to pass to ctags. This may be different from the
+    " file type detected by Vim
+    let pos = stridx(settings, ';')
+    if pos == -1
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    let ctags_ftype = strpart(settings, 0, pos)
+    if ctags_ftype == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+    " Make sure a valid filetype is supplied. If the user didn't specify a
+    " valid filetype, then the ctags option settings may be treated as the
+    " filetype
+    if ctags_ftype =~ ':'
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Remove the file type from settings
+    let settings = strpart(settings, pos + 1)
+    if settings == ''
+        call s:Tlist_Warning_Msg(msg)
+        return 0
+    endif
+
+    " Process all the specified ctags flags. The format is
+    " flag1:name1;flag2:name2;flag3:name3
+    let ctags_flags = ''
+    let cnt = 0
+    while settings != ''
+        " Extract the flag
+        let pos = stridx(settings, ':')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let flag = strpart(settings, 0, pos)
+        if flag == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        " Remove the flag from settings
+        let settings = strpart(settings, pos + 1)
+
+        " Extract the tag type name
+        let pos = stridx(settings, ';')
+        if pos == -1
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let name = strpart(settings, 0, pos)
+        if name == ''
+            call s:Tlist_Warning_Msg(msg)
+            return 0
+        endif
+        let settings = strpart(settings, pos + 1)
+
+        let cnt = cnt + 1
+
+        let s:tlist_{a:ftype}_{cnt}_name = flag
+        let s:tlist_{a:ftype}_{cnt}_fullname = name
+        let ctags_flags = ctags_flags . flag
+    endwhile
+
+    let s:tlist_{a:ftype}_ctags_args = '--language-force=' . ctags_ftype .
+                            \ ' --' . ctags_ftype . '-types=' . ctags_flags
+    let s:tlist_{a:ftype}_count = cnt
+    let s:tlist_{a:ftype}_ctags_flags = ctags_flags
+
+    " Save the filetype name
+    let s:tlist_ftype_{s:tlist_ftype_count}_name = a:ftype
+    let s:tlist_ftype_count = s:tlist_ftype_count + 1
+
+    return 1
+endfunction
+
+" Tlist_Get_Filetype
+" Determine the filetype for the specified file
+function! s:Tlist_Get_Filetype(fname)
+    " Ignore the filetype autocommands
+    let old_eventignore = &eventignore
+    set eventignore=FileType
+
+    " Save the 'filetype', as this will be changed temporarily
+    let old_filetype = &filetype
+
+    " Run the filetypedetect group of autocommands to determine
+    " the filetype
+    exe 'doautocmd filetypedetect BufRead ' . a:fname
+
+    " Save the detected filetype
+    let ftype = &filetype
+
+    " Restore the previous state
+    let &filetype = old_filetype
+    let &eventignore = old_eventignore
+
+    return ftype
+endfunction
+
+" Tlist_Get_Buffer_Filetype
+" Get the filetype for the specified buffer
+function! s:Tlist_Get_Buffer_Filetype(bnum)
+    if bufloaded(a:bnum)
+        " For loaded buffers, the 'filetype' is already determined
+        return getbufvar(a:bnum, '&filetype')
+    endif
+
+    " For unloaded buffers, if the 'filetype' option is set, return it
+    let ftype = getbufvar(a:bnum, '&filetype')
+    if ftype != ''
+        return ftype
+    endif
+
+    " Skip non-existent buffers
+    if !bufexists(a:bnum)
+        return ''
+    endif
+
+    " For buffers whose filetype is not yet determined, try to determine
+    " the filetype
+    let bname = bufname(a:bnum)
+
+    return s:Tlist_Get_Filetype(bname)
+endfunction
+
+" Tlist_Discard_TagInfo
+" Discard the stored tag information for a file
+function! s:Tlist_Discard_TagInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_TagInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Discard information about the tags defined in the file
+    let i = 1
+    while i <= s:tlist_{a:fidx}_tag_count
+        let fidx_i = 's:tlist_' . a:fidx . '_' . i
+        unlet! {fidx_i}_tag
+        unlet! {fidx_i}_tag_name
+        unlet! {fidx_i}_tag_type
+        unlet! {fidx_i}_ttype_idx
+        unlet! {fidx_i}_tag_proto
+        unlet! {fidx_i}_tag_searchpat
+        unlet! {fidx_i}_tag_linenum
+        let i = i + 1
+    endwhile
+
+    let s:tlist_{a:fidx}_tag_count = 0
+
+    " Discard information about tag type groups
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{a:fidx}_{ttype} != ''
+            let fidx_ttype = 's:tlist_' . a:fidx . '_' . ttype
+            let {fidx_ttype} = ''
+            let {fidx_ttype}_offset = 0
+            let cnt = {fidx_ttype}_count
+            let {fidx_ttype}_count = 0
+            let j = 1
+            while j <= cnt
+                unlet! {fidx_ttype}_{j}
+                let j = j + 1
+            endwhile
+        endif
+        let i = i + 1
+    endwhile
+
+    " Discard the stored menu command also
+    let s:tlist_{a:fidx}_menu_cmd = ''
+endfunction
+
+" Tlist_Window_Update_Line_Offsets
+" Update the line offsets for tags for files starting from start_idx
+" and displayed in the taglist window by the specified offset
+function! s:Tlist_Window_Update_Line_Offsets(start_idx, increment, offset)
+    let i = a:start_idx
+
+    while i < s:tlist_file_count
+        if s:tlist_{i}_visible
+            " Update the start/end line number only if the file is visible
+            if a:increment
+                let s:tlist_{i}_start = s:tlist_{i}_start + a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end + a:offset
+            else
+                let s:tlist_{i}_start = s:tlist_{i}_start - a:offset
+                let s:tlist_{i}_end = s:tlist_{i}_end - a:offset
+            endif
+        endif
+        let i = i + 1
+    endwhile
+endfunction
+
+" Tlist_Discard_FileInfo
+" Discard the stored information for a file
+function! s:Tlist_Discard_FileInfo(fidx)
+    call s:Tlist_Log_Msg('Tlist_Discard_FileInfo (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    call s:Tlist_Discard_TagInfo(a:fidx)
+
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        unlet! s:tlist_{a:fidx}_{ttype}
+        unlet! s:tlist_{a:fidx}_{ttype}_offset
+        unlet! s:tlist_{a:fidx}_{ttype}_count
+        let i = i + 1
+    endwhile
+
+    unlet! s:tlist_{a:fidx}_filename
+    unlet! s:tlist_{a:fidx}_sort_type
+    unlet! s:tlist_{a:fidx}_filetype
+    unlet! s:tlist_{a:fidx}_mtime
+    unlet! s:tlist_{a:fidx}_start
+    unlet! s:tlist_{a:fidx}_end
+    unlet! s:tlist_{a:fidx}_valid
+    unlet! s:tlist_{a:fidx}_visible
+    unlet! s:tlist_{a:fidx}_tag_count
+    unlet! s:tlist_{a:fidx}_menu_cmd
+endfunction
+
+" Tlist_Window_Remove_File_From_Display
+" Remove the specified file from display
+function! s:Tlist_Window_Remove_File_From_Display(fidx)
+    call s:Tlist_Log_Msg('Tlist_Window_Remove_File_From_Display (' .
+                \ s:tlist_{a:fidx}_filename . ')')
+    " If the file is not visible then no need to remove it
+    if !s:tlist_{a:fidx}_visible
+        return
+    endif
+
+    " Remove the tags displayed for the specified file from the window
+    let start = s:tlist_{a:fidx}_start
+    " Include the empty line after the last line also
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{a:fidx}_end
+    else
+        let end = s:tlist_{a:fidx}_end + 1
+    endif
+
+    setlocal modifiable
+    exe 'silent! ' . start . ',' . end . 'delete _'
+    setlocal nomodifiable
+
+    " Correct the start and end line offsets for all the files following
+    " this file, as the tags for this file are removed
+    call s:Tlist_Window_Update_Line_Offsets(a:fidx + 1, 0, end - start + 1)
+endfunction
+
+" Tlist_Remove_File
+" Remove the file under the cursor or the specified file index
+" user_request - User requested to remove the file from taglist
+function! s:Tlist_Remove_File(file_idx, user_request)
+    let fidx = a:file_idx
+
+    if fidx == -1
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+    endif
+    call s:Tlist_Log_Msg('Tlist_Remove_File (' .
+                \ s:tlist_{fidx}_filename . ', ' . a:user_request . ')')
+
+    let save_winnr = winnr()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Taglist window is open, remove the file from display
+
+        if save_winnr != winnum
+            let old_eventignore = &eventignore
+            set eventignore=all
+            exe winnum . 'wincmd w'
+        endif
+
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+
+        if save_winnr != winnum
+            exe save_winnr . 'wincmd w'
+            let &eventignore = old_eventignore
+        endif
+    endif
+
+    let fname = s:tlist_{fidx}_filename
+
+    if a:user_request
+        " As the user requested to remove the file from taglist,
+        " add it to the removed list
+        call s:Tlist_Update_Remove_List(fname, 1)
+    endif
+
+    " Remove the file name from the taglist list of filenames
+    let idx = stridx(s:tlist_file_names, fname . "\n")
+    let text_before = strpart(s:tlist_file_names, 0, idx)
+    let rem_text = strpart(s:tlist_file_names, idx)
+    let next_idx = stridx(rem_text, "\n")
+    let text_after = strpart(rem_text, next_idx + 1)
+    let s:tlist_file_names = text_before . text_after
+
+    call s:Tlist_Discard_FileInfo(fidx)
+
+    " Shift all the file variables by one index
+    let i = fidx + 1
+
+    while i < s:tlist_file_count
+        let j = i - 1
+
+        let s:tlist_{j}_filename = s:tlist_{i}_filename
+        let s:tlist_{j}_sort_type = s:tlist_{i}_sort_type
+        let s:tlist_{j}_filetype = s:tlist_{i}_filetype
+        let s:tlist_{j}_mtime = s:tlist_{i}_mtime
+        let s:tlist_{j}_start = s:tlist_{i}_start
+        let s:tlist_{j}_end = s:tlist_{i}_end
+        let s:tlist_{j}_valid = s:tlist_{i}_valid
+        let s:tlist_{j}_visible = s:tlist_{i}_visible
+        let s:tlist_{j}_tag_count = s:tlist_{i}_tag_count
+        let s:tlist_{j}_menu_cmd = s:tlist_{i}_menu_cmd
+
+        let k = 1
+        while k <= s:tlist_{j}_tag_count
+            let s:tlist_{j}_{k}_tag = s:tlist_{i}_{k}_tag
+            let s:tlist_{j}_{k}_tag_name = s:tlist_{i}_{k}_tag_name
+            let s:tlist_{j}_{k}_tag_type = s:Tlist_Get_Tag_Type_By_Tag(i, k)
+            let s:tlist_{j}_{k}_ttype_idx = s:tlist_{i}_{k}_ttype_idx
+            let s:tlist_{j}_{k}_tag_proto = s:Tlist_Get_Tag_Prototype(i, k)
+            let s:tlist_{j}_{k}_tag_searchpat = s:Tlist_Get_Tag_SearchPat(i, k)
+            let s:tlist_{j}_{k}_tag_linenum = s:Tlist_Get_Tag_Linenum(i, k)
+            let k = k + 1
+        endwhile
+
+        let ftype = s:tlist_{i}_filetype
+
+        let k = 1
+        while k <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{k}_name
+            let s:tlist_{j}_{ttype} = s:tlist_{i}_{ttype}
+            let s:tlist_{j}_{ttype}_offset = s:tlist_{i}_{ttype}_offset
+            let s:tlist_{j}_{ttype}_count = s:tlist_{i}_{ttype}_count
+            if s:tlist_{j}_{ttype} != ''
+                let l = 1
+                while l <= s:tlist_{j}_{ttype}_count
+                    let s:tlist_{j}_{ttype}_{l} = s:tlist_{i}_{ttype}_{l}
+                    let l = l + 1
+                endwhile
+            endif
+            let k = k + 1
+        endwhile
+
+        " As the file and tag information is copied to the new index,
+        " discard the previous information
+        call s:Tlist_Discard_FileInfo(i)
+
+        let i = i + 1
+    endwhile
+
+    " Reduce the number of files displayed
+    let s:tlist_file_count = s:tlist_file_count - 1
+
+    if g:Tlist_Show_One_File
+        " If the tags for only one file is displayed and if we just
+        " now removed that file, then invalidate the current file idx
+        if s:tlist_cur_file_idx == fidx
+            let s:tlist_cur_file_idx = -1
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Goto_Window
+" Goto the taglist window
+function! s:Tlist_Window_Goto_Window()
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        if winnr() != winnum
+            call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Create
+" Create a new taglist window. If it is already open, jump to it
+function! s:Tlist_Window_Create()
+    call s:Tlist_Log_Msg('Tlist_Window_Create()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    " If used with winmanager don't open windows. Winmanager will handle
+    " the window/buffer management
+    if s:tlist_app_name == "winmanager"
+        return
+    endif
+
+    " Create a new window. If user prefers a horizontal window, then open
+    " a horizontally split window. Otherwise open a vertically split
+    " window
+    if g:Tlist_Use_Horiz_Window
+        " Open a horizontally split window
+        let win_dir = 'botright'
+        " Horizontal window height
+        let win_size = g:Tlist_WinHeight
+    else
+        if s:tlist_winsize_chgd == -1
+            " Open a vertically split window. Increase the window size, if
+            " needed, to accomodate the new window
+            if g:Tlist_Inc_Winwidth &&
+                        \ &columns < (80 + g:Tlist_WinWidth)
+                " Save the original window position
+                let s:tlist_pre_winx = getwinposx()
+                let s:tlist_pre_winy = getwinposy()
+
+                " one extra column is needed to include the vertical split
+                let &columns= &columns + g:Tlist_WinWidth + 1
+
+                let s:tlist_winsize_chgd = 1
+            else
+                let s:tlist_winsize_chgd = 0
+            endif
+        endif
+
+        if g:Tlist_Use_Right_Window
+            " Open the window at the rightmost place
+            let win_dir = 'botright vertical'
+        else
+            " Open the window at the leftmost place
+            let win_dir = 'topleft vertical'
+        endif
+        let win_size = g:Tlist_WinWidth
+    endif
+
+    " If the tag listing temporary buffer already exists, then reuse it.
+    " Otherwise create a new buffer
+    let bufnum = bufnr(g:TagList_title)
+    if bufnum == -1
+        " Create a new buffer
+        let wcmd = g:TagList_title
+    else
+        " Edit the existing buffer
+        let wcmd = '+buffer' . bufnum
+    endif
+
+    " Create the taglist window
+    exe 'silent! ' . win_dir . ' ' . win_size . 'split ' . wcmd
+
+    " Save the new window position
+    let s:tlist_winx = getwinposx()
+    let s:tlist_winy = getwinposy()
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+endfunction
+
+" Tlist_Window_Zoom
+" Zoom (maximize/minimize) the taglist window
+function! s:Tlist_Window_Zoom()
+    if s:tlist_win_maximized
+        " Restore the window back to the previous size
+        if g:Tlist_Use_Horiz_Window
+            exe 'resize ' . g:Tlist_WinHeight
+        else
+            exe 'vert resize ' . g:Tlist_WinWidth
+        endif
+        let s:tlist_win_maximized = 0
+    else
+        " Set the window size to the maximum possible without closing other
+        " windows
+        if g:Tlist_Use_Horiz_Window
+            resize
+        else
+            vert resize
+        endif
+        let s:tlist_win_maximized = 1
+    endif
+endfunction
+
+" Tlist_Ballon_Expr
+" When the mouse cursor is over a tag in the taglist window, display the
+" tag prototype (balloon)
+function! Tlist_Ballon_Expr()
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(v:beval_lnum)
+    if fidx == -1
+        return ''
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, v:beval_lnum)
+    if tidx == 0
+        return ''
+    endif
+
+    " Get the tag search pattern and display it
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Window_Check_Width
+" Check the width of the taglist window. For horizontally split windows, the
+" 'winfixheight' option is used to fix the height of the window. For
+" vertically split windows, Vim doesn't support the 'winfixwidth' option. So
+" need to handle window width changes from this function.
+function! s:Tlist_Window_Check_Width()
+    let tlist_winnr = bufwinnr(g:TagList_title)
+    if tlist_winnr == -1
+        return
+    endif
+
+    let width = winwidth(tlist_winnr)
+    if width != g:Tlist_WinWidth
+        call s:Tlist_Log_Msg("Tlist_Window_Check_Width: Changing window " .
+                    \ "width from " . width . " to " . g:Tlist_WinWidth)
+        let save_winnr = winnr()
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds(tlist_winnr . 'wincmd w')
+        endif
+        exe 'vert resize ' . g:Tlist_WinWidth
+        if save_winnr != tlist_winnr
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Exit_Only_Window
+" If the 'Tlist_Exit_OnlyWindow' option is set, then exit Vim if only the
+" taglist window is present.
+function! s:Tlist_Window_Exit_Only_Window()
+    " Before quitting Vim, delete the taglist buffer so that
+    " the '0 mark is correctly set to the previous buffer.
+    if v:version < 700
+	if winbufnr(2) == -1
+	    bdelete
+	    quit
+	endif
+    else
+	if winbufnr(2) == -1
+	    if tabpagenr('$') == 1
+		" Only one tag page is present
+		bdelete
+		quit
+	    else
+		" More than one tab page is present. Close only the current
+		" tab page
+		close
+	    endif
+	endif
+    endif
+endfunction
+
+" Tlist_Window_Init
+" Set the default options for the taglist window
+function! s:Tlist_Window_Init()
+    call s:Tlist_Log_Msg('Tlist_Window_Init()')
+
+    " The 'readonly' option should not be set for the taglist buffer.
+    " If Vim is started as "view/gview" or if the ":view" command is
+    " used, then the 'readonly' option is set for all the buffers.
+    " Unset it for the taglist buffer
+    setlocal noreadonly
+
+    " Set the taglist buffer filetype to taglist
+    setlocal filetype=taglist
+
+    " Define taglist window element highlighting
+    syntax match TagListComment '^" .*'
+    syntax match TagListFileName '^[^" ].*$'
+    syntax match TagListTitle '^  \S.*$'
+    syntax match TagListTagScope  '\s\[.\{-\}\]$'
+
+    " Define the highlighting only if colors are supported
+    if has('gui_running') || &t_Co > 2
+        " Colors to highlight various taglist window elements
+        " If user defined highlighting group exists, then use them.
+        " Otherwise, use default highlight groups.
+        if hlexists('MyTagListTagName')
+            highlight link TagListTagName MyTagListTagName
+        else
+            highlight default link TagListTagName Search
+        endif
+        " Colors to highlight comments and titles
+        if hlexists('MyTagListComment')
+            highlight link TagListComment MyTagListComment
+        else
+            highlight clear TagListComment
+            highlight default link TagListComment Comment
+        endif
+        if hlexists('MyTagListTitle')
+            highlight link TagListTitle MyTagListTitle
+        else
+            highlight clear TagListTitle
+            highlight default link TagListTitle Title
+        endif
+        if hlexists('MyTagListFileName')
+            highlight link TagListFileName MyTagListFileName
+        else
+            highlight clear TagListFileName
+            highlight default TagListFileName guibg=Grey ctermbg=darkgray
+                        \ guifg=white ctermfg=white
+        endif
+        if hlexists('MyTagListTagScope')
+            highlight link TagListTagScope MyTagListTagScope
+        else
+            highlight clear TagListTagScope
+            highlight default link TagListTagScope Identifier
+        endif
+    else
+        highlight default TagListTagName term=reverse cterm=reverse
+    endif
+
+    " Folding related settings
+    setlocal foldenable
+    setlocal foldminlines=0
+    setlocal foldmethod=manual
+    setlocal foldlevel=9999
+    if g:Tlist_Enable_Fold_Column
+        setlocal foldcolumn=3
+    else
+        setlocal foldcolumn=0
+    endif
+    setlocal foldtext=v:folddashes.getline(v:foldstart)
+
+    if s:tlist_app_name != "winmanager"
+        " Mark buffer as scratch
+        silent! setlocal buftype=nofile
+        if s:tlist_app_name == "none"
+            silent! setlocal bufhidden=delete
+        endif
+        silent! setlocal noswapfile
+        " Due to a bug in Vim 6.0, the winbufnr() function fails for unlisted
+        " buffers. So if the taglist buffer is unlisted, multiple taglist
+        " windows will be opened. This bug is fixed in Vim 6.1 and above
+        if v:version >= 601
+            silent! setlocal nobuflisted
+        endif
+    endif
+
+    silent! setlocal nowrap
+
+    " If the 'number' option is set in the source window, it will affect the
+    " taglist window. So forcefully disable 'number' option for the taglist
+    " window
+    silent! setlocal nonumber
+
+    " Use fixed height when horizontally split window is used
+    if g:Tlist_Use_Horiz_Window
+        if v:version >= 602
+            set winfixheight
+        endif
+    endif
+    if !g:Tlist_Use_Horiz_Window && v:version >= 700
+        set winfixwidth
+    endif
+
+    " Setup balloon evaluation to display tag prototype
+    if v:version >= 700 && has('balloon_eval')
+        setlocal balloonexpr=Tlist_Ballon_Expr()
+        set ballooneval
+    endif
+
+    " Setup the cpoptions properly for the maps to work
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    " Create buffer local mappings for jumping to the tags and sorting the list
+    nnoremap <buffer> <silent> <CR>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> o
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    nnoremap <buffer> <silent> p
+                \ :call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    nnoremap <buffer> <silent> P
+                \ :call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    nnoremap <buffer> <silent> t
+                \ :call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    nnoremap <buffer> <silent> <C-t>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    nnoremap <buffer> <silent> <2-LeftMouse>
+                \ :call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    nnoremap <buffer> <silent> s
+                \ :call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    nnoremap <buffer> <silent> + :silent! foldopen<CR>
+    nnoremap <buffer> <silent> - :silent! foldclose<CR>
+    nnoremap <buffer> <silent> * :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> = :silent! %foldclose<CR>
+    nnoremap <buffer> <silent> <kPlus> :silent! foldopen<CR>
+    nnoremap <buffer> <silent> <kMinus> :silent! foldclose<CR>
+    nnoremap <buffer> <silent> <kMultiply> :silent! %foldopen!<CR>
+    nnoremap <buffer> <silent> <Space> :call <SID>Tlist_Window_Show_Info()<CR>
+    nnoremap <buffer> <silent> u :call <SID>Tlist_Window_Update_File()<CR>
+    nnoremap <buffer> <silent> d :call <SID>Tlist_Remove_File(-1, 1)<CR>
+    nnoremap <buffer> <silent> x :call <SID>Tlist_Window_Zoom()<CR>
+    nnoremap <buffer> <silent> [[ :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> <BS> :call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    nnoremap <buffer> <silent> ]] :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <Tab> :call <SID>Tlist_Window_Move_To_File(1)<CR>
+    nnoremap <buffer> <silent> <F1> :call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    nnoremap <buffer> <silent> q :close<CR>
+
+    " Insert mode mappings
+    inoremap <buffer> <silent> <CR>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    " Windows needs return
+    inoremap <buffer> <silent> <Return>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> o
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newwin')<CR>
+    inoremap <buffer> <silent> p
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('preview')<CR>
+    inoremap <buffer> <silent> P
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('prevwin')<CR>
+    if v:version >= 700
+    inoremap <buffer> <silent> t
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('checktab')<CR>
+    inoremap <buffer> <silent> <C-t>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('newtab')<CR>
+    endif
+    inoremap <buffer> <silent> <2-LeftMouse>
+                \ <C-o>:call <SID>Tlist_Window_Jump_To_Tag('useopen')<CR>
+    inoremap <buffer> <silent> s
+                \ <C-o>:call <SID>Tlist_Change_Sort('cmd', 'toggle', '')<CR>
+    inoremap <buffer> <silent> +             <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> -             <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> *             <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> =             <C-o>:silent! %foldclose<CR>
+    inoremap <buffer> <silent> <kPlus>       <C-o>:silent! foldopen<CR>
+    inoremap <buffer> <silent> <kMinus>      <C-o>:silent! foldclose<CR>
+    inoremap <buffer> <silent> <kMultiply>   <C-o>:silent! %foldopen!<CR>
+    inoremap <buffer> <silent> <Space>       <C-o>:call
+                                    \ <SID>Tlist_Window_Show_Info()<CR>
+    inoremap <buffer> <silent> u
+                            \ <C-o>:call <SID>Tlist_Window_Update_File()<CR>
+    inoremap <buffer> <silent> d    <C-o>:call <SID>Tlist_Remove_File(-1, 1)<CR>
+    inoremap <buffer> <silent> x    <C-o>:call <SID>Tlist_Window_Zoom()<CR>
+    inoremap <buffer> <silent> [[   <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> <BS> <C-o>:call <SID>Tlist_Window_Move_To_File(-1)<CR>
+    inoremap <buffer> <silent> ]]   <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <Tab> <C-o>:call <SID>Tlist_Window_Move_To_File(1)<CR>
+    inoremap <buffer> <silent> <F1>  <C-o>:call <SID>Tlist_Window_Toggle_Help_Text()<CR>
+    inoremap <buffer> <silent> q    <C-o>:close<CR>
+
+    " Map single left mouse click if the user wants this functionality
+    if g:Tlist_Use_SingleClick == 1
+        " Contributed by Bindu Wavell
+        " attempt to perform single click mapping, it would be much
+        " nicer if we could nnoremap <buffer> ... however vim does
+        " not fire the <buffer> <leftmouse> when you use the mouse
+        " to enter a buffer.
+        let clickmap = ':if bufname("%") =~ "__Tag_List__" <bar> ' .
+                    \ 'call <SID>Tlist_Window_Jump_To_Tag("useopen") ' .
+                    \ '<bar> endif <CR>'
+        if maparg('<leftmouse>', 'n') == ''
+            " no mapping for leftmouse
+            exe ':nnoremap <silent> <leftmouse> <leftmouse>' . clickmap
+        else
+            " we have a mapping
+            let mapcmd = ':nnoremap <silent> <leftmouse> <leftmouse>'
+            let mapcmd = mapcmd . substitute(substitute(
+                        \ maparg('<leftmouse>', 'n'), '|', '<bar>', 'g'),
+                        \ '\c^<leftmouse>', '', '')
+            let mapcmd = mapcmd . clickmap
+            exe mapcmd
+        endif
+    endif
+
+    " Define the taglist autocommands
+    augroup TagListAutoCmds
+        autocmd!
+        " Display the tag prototype for the tag under the cursor.
+        autocmd CursorHold __Tag_List__ call s:Tlist_Window_Show_Info()
+        " Highlight the current tag periodically
+        autocmd CursorHold * silent call s:Tlist_Window_Highlight_Tag(
+                            \ fnamemodify(bufname('%'), ':p'), line('.'), 1, 0)
+
+        " Adjust the Vim window width when taglist window is closed
+        autocmd BufUnload __Tag_List__ call s:Tlist_Post_Close_Cleanup()
+        " Close the fold for this buffer when leaving the buffer
+        if g:Tlist_File_Fold_Auto_Close
+            autocmd BufEnter * silent
+                \ call s:Tlist_Window_Open_File_Fold(expand('<afile>'))
+        endif
+        " Exit Vim itself if only the taglist window is present (optional)
+        if g:Tlist_Exit_OnlyWindow
+	    autocmd BufEnter __Tag_List__ nested
+			\ call s:Tlist_Window_Exit_Only_Window()
+        endif
+        if s:tlist_app_name != "winmanager" &&
+                    \ !g:Tlist_Process_File_Always &&
+                    \ (!has('gui_running') || !g:Tlist_Show_Menu)
+            " Auto refresh the taglist window
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+
+        if !g:Tlist_Use_Horiz_Window
+            if v:version < 700
+                autocmd WinEnter * call s:Tlist_Window_Check_Width()
+            endif
+        endif
+    augroup end
+
+    " Restore the previous cpoptions settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Window_Refresh
+" Display the tags for all the files in the taglist window
+function! s:Tlist_Window_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh()')
+    " Set report option to a huge value to prevent informational messages
+    " while deleting the lines
+    let old_report = &report
+    set report=99999
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Delete the contents of the buffer to the black-hole register
+    silent! %delete _
+
+    " As we have cleared the taglist window, mark all the files
+    " as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Compact_Format == 0
+        " Display help in non-compact mode
+        call s:Tlist_Window_Display_Help()
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " If the tags for only one file should be displayed in the taglist
+    " window, then no need to add the tags here. The bufenter autocommand
+    " will add the tags for that file.
+    if g:Tlist_Show_One_File
+        return
+    endif
+
+    " List all the tags for the previously processed files
+    " Do this only if taglist is configured to display tags for more than
+    " one file. Otherwise, when Tlist_Show_One_File is configured,
+    " tags for the wrong file will be displayed.
+    let i = 0
+    while i < s:tlist_file_count
+        call s:Tlist_Window_Refresh_File(s:tlist_{i}_filename,
+                    \ s:tlist_{i}_filetype)
+        let i = i + 1
+    endwhile
+
+    if g:Tlist_Auto_Update
+        " Add and list the tags for all buffers in the Vim buffer list
+        let i = 1
+        let last_bufnum = bufnr('$')
+        while i <= last_bufnum
+            if buflisted(i)
+                let fname = fnamemodify(bufname(i), ':p')
+                let ftype = s:Tlist_Get_Buffer_Filetype(i)
+                " If the file doesn't support tag listing, skip it
+                if !s:Tlist_Skip_File(fname, ftype)
+                    call s:Tlist_Window_Refresh_File(fname, ftype)
+                endif
+            endif
+            let i = i + 1
+        endwhile
+    endif
+
+    " If Tlist_File_Fold_Auto_Close option is set, then close all the folds
+    if g:Tlist_File_Fold_Auto_Close
+        " Close all the folds
+        silent! %foldclose
+    endif
+
+    " Move the cursor to the top of the taglist window
+    normal! gg
+endfunction
+
+" Tlist_Post_Close_Cleanup()
+" Close the taglist window and adjust the Vim window width
+function! s:Tlist_Post_Close_Cleanup()
+    call s:Tlist_Log_Msg('Tlist_Post_Close_Cleanup()')
+    " Mark all the files as not visible
+    let i = 0
+    while i < s:tlist_file_count
+        let s:tlist_{i}_visible = 0
+        let i = i + 1
+    endwhile
+
+    " Remove the taglist autocommands
+    silent! autocmd! TagListAutoCmds
+
+    " Clear all the highlights
+    match none
+
+    silent! syntax clear TagListTitle
+    silent! syntax clear TagListComment
+    silent! syntax clear TagListTagScope
+
+    " Remove the left mouse click mapping if it was setup initially
+    if g:Tlist_Use_SingleClick
+        if hasmapto('<LeftMouse>')
+            nunmap <LeftMouse>
+        endif
+    endif
+
+    if s:tlist_app_name != "winmanager"
+    if g:Tlist_Use_Horiz_Window || g:Tlist_Inc_Winwidth == 0 ||
+                \ s:tlist_winsize_chgd != 1 ||
+                \ &columns < (80 + g:Tlist_WinWidth)
+        " No need to adjust window width if using horizontally split taglist
+        " window or if columns is less than 101 or if the user chose not to
+        " adjust the window width
+    else
+        " If the user didn't manually move the window, then restore the window
+        " position to the pre-taglist position
+        if s:tlist_pre_winx != -1 && s:tlist_pre_winy != -1 &&
+                    \ getwinposx() == s:tlist_winx &&
+                    \ getwinposy() == s:tlist_winy
+            exe 'winpos ' . s:tlist_pre_winx . ' ' . s:tlist_pre_winy
+        endif
+
+        " Adjust the Vim window width
+        let &columns= &columns - (g:Tlist_WinWidth + 1)
+    endif
+    endif
+
+    let s:tlist_winsize_chgd = -1
+
+    " Reset taglist state variables
+    if s:tlist_app_name == "winmanager"
+        let s:tlist_app_name = "none"
+    endif
+    let s:tlist_window_initialized = 0
+endfunction
+
+" Tlist_Window_Refresh_File()
+" List the tags defined in the specified file in a Vim window
+function! s:Tlist_Window_Refresh_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Window_Refresh_File (' . a:filename . ')')
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx != -1
+        let file_listed = 1
+    else
+        let file_listed = 0
+    endif
+
+    if !file_listed
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(a:filename)
+            return
+        endif
+    endif
+
+    if file_listed && s:tlist_{fidx}_visible
+        " Check whether the file tags are currently valid
+        if s:tlist_{fidx}_valid
+            " Goto the first line in the file
+            exe s:tlist_{fidx}_start
+
+            " If the line is inside a fold, open the fold
+            if foldclosed('.') != -1
+                exe "silent! " . s:tlist_{fidx}_start . "," .
+                            \ s:tlist_{fidx}_end . "foldopen!"
+            endif
+            return
+        endif
+
+        " Discard and remove the tags for this file from display
+        call s:Tlist_Discard_TagInfo(fidx)
+        call s:Tlist_Window_Remove_File_From_Display(fidx)
+    endif
+
+    " Process and generate a list of tags defined in the file
+    if !file_listed || !s:tlist_{fidx}_valid
+        let ret_fidx = s:Tlist_Process_File(a:filename, a:ftype)
+        if ret_fidx == -1
+            return
+        endif
+        let fidx = ret_fidx
+    endif
+
+    " Set report option to a huge value to prevent informational messages
+    " while adding lines to the taglist window
+    let old_report = &report
+    set report=99999
+
+    if g:Tlist_Show_One_File
+        " Remove the previous file
+        if s:tlist_cur_file_idx != -1
+            call s:Tlist_Window_Remove_File_From_Display(s:tlist_cur_file_idx)
+            let s:tlist_{s:tlist_cur_file_idx}_visible = 0
+            let s:tlist_{s:tlist_cur_file_idx}_start = 0
+            let s:tlist_{s:tlist_cur_file_idx}_end = 0
+        endif
+        let s:tlist_cur_file_idx = fidx
+    endif
+
+    " Mark the buffer as modifiable
+    setlocal modifiable
+
+    " Add new files to the end of the window. For existing files, add them at
+    " the same line where they were previously present. If the file is not
+    " visible, then add it at the end
+    if s:tlist_{fidx}_start == 0 || !s:tlist_{fidx}_visible
+        if g:Tlist_Compact_Format
+            let s:tlist_{fidx}_start = line('$')
+        else
+            let s:tlist_{fidx}_start = line('$') + 1
+        endif
+    endif
+
+    let s:tlist_{fidx}_visible = 1
+
+    " Goto the line where this file should be placed
+    if g:Tlist_Compact_Format
+        exe s:tlist_{fidx}_start
+    else
+        exe s:tlist_{fidx}_start - 1
+    endif
+
+    let txt = fnamemodify(s:tlist_{fidx}_filename, ':t') . ' (' .
+                \ fnamemodify(s:tlist_{fidx}_filename, ':p:h') . ')'
+    if g:Tlist_Compact_Format == 0
+        silent! put =txt
+    else
+        silent! put! =txt
+        " Move to the next line
+        exe line('.') + 1
+    endif
+    let file_start = s:tlist_{fidx}_start
+
+    " Add the tag names grouped by tag type to the buffer with a title
+    let i = 1
+    let ttype_cnt = s:tlist_{a:ftype}_count
+    while i <= ttype_cnt
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        " Add the tag type only if there are tags for that type
+        let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+        let ttype_txt = {fidx_ttype}
+        if ttype_txt != ''
+            let txt = '  ' . s:tlist_{a:ftype}_{i}_fullname
+            if g:Tlist_Compact_Format == 0
+                let ttype_start_lnum = line('.') + 1
+                silent! put =txt
+            else
+                let ttype_start_lnum = line('.')
+                silent! put! =txt
+            endif
+            silent! put =ttype_txt
+
+            let {fidx_ttype}_offset = ttype_start_lnum - file_start
+
+            " create a fold for this tag type
+            let fold_start = ttype_start_lnum
+            let fold_end = fold_start + {fidx_ttype}_count
+            exe fold_start . ',' . fold_end  . 'fold'
+
+            " Adjust the cursor position
+            if g:Tlist_Compact_Format == 0
+                exe ttype_start_lnum + {fidx_ttype}_count
+            else
+                exe ttype_start_lnum + {fidx_ttype}_count + 1
+            endif
+
+            if g:Tlist_Compact_Format == 0
+                " Separate the tag types by a empty line
+                silent! put =''
+            endif
+        endif
+        let i = i + 1
+    endwhile
+
+    if s:tlist_{fidx}_tag_count == 0
+        if g:Tlist_Compact_Format == 0
+            silent! put =''
+        endif
+    endif
+
+    let s:tlist_{fidx}_end = line('.') - 1
+
+    " Create a fold for the entire file
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'fold'
+    exe 'silent! ' . s:tlist_{fidx}_start . ',' .
+                \ s:tlist_{fidx}_end . 'foldopen!'
+
+    " Goto the starting line for this file,
+    exe s:tlist_{fidx}_start
+
+    if s:tlist_app_name == "winmanager"
+        " To handle a bug in the winmanager plugin, add a space at the
+        " last line
+        call setline('$', ' ')
+    endif
+
+    " Mark the buffer as not modifiable
+    setlocal nomodifiable
+
+    " Restore the report option
+    let &report = old_report
+
+    " Update the start and end line numbers for all the files following this
+    " file
+    let start = s:tlist_{fidx}_start
+    " include the empty line after the last line
+    if g:Tlist_Compact_Format
+        let end = s:tlist_{fidx}_end
+    else
+        let end = s:tlist_{fidx}_end + 1
+    endif
+    call s:Tlist_Window_Update_Line_Offsets(fidx + 1, 1, end - start + 1)
+
+    " Now that we have updated the taglist window, update the tags
+    " menu (if present)
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Init_File
+" Initialize the variables for a new file
+function! s:Tlist_Init_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Init_File (' . a:filename . ')')
+    " Add new files at the end of the list
+    let fidx = s:tlist_file_count
+    let s:tlist_file_count = s:tlist_file_count + 1
+    " Add the new file name to the taglist list of file names
+    let s:tlist_file_names = s:tlist_file_names . a:filename . "\n"
+
+    " Initialize the file variables
+    let s:tlist_{fidx}_filename = a:filename
+    let s:tlist_{fidx}_sort_type = g:Tlist_Sort_Type
+    let s:tlist_{fidx}_filetype = a:ftype
+    let s:tlist_{fidx}_mtime = -1
+    let s:tlist_{fidx}_start = 0
+    let s:tlist_{fidx}_end = 0
+    let s:tlist_{fidx}_valid = 0
+    let s:tlist_{fidx}_visible = 0
+    let s:tlist_{fidx}_tag_count = 0
+    let s:tlist_{fidx}_menu_cmd = ''
+
+    " Initialize the tag type variables
+    let i = 1
+    while i <= s:tlist_{a:ftype}_count
+        let ttype = s:tlist_{a:ftype}_{i}_name
+        let s:tlist_{fidx}_{ttype} = ''
+        let s:tlist_{fidx}_{ttype}_offset = 0
+        let s:tlist_{fidx}_{ttype}_count = 0
+        let i = i + 1
+    endwhile
+
+    return fidx
+endfunction
+
+" Tlist_Get_Tag_Type_By_Tag
+" Return the tag type for the specified tag index
+function! s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+    let ttype_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_type'
+
+    " Already parsed and have the tag name
+    if exists(ttype_var)
+        return {ttype_var}
+    endif
+
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let {ttype_var} = s:Tlist_Extract_Tagtype(tag_line)
+
+    return {ttype_var}
+endfunction
+
+" Tlist_Get_Tag_Prototype
+function! s:Tlist_Get_Tag_Prototype(fidx, tidx)
+    let tproto_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_proto'
+
+    " Already parsed and have the tag prototype
+    if exists(tproto_var)
+        return {tproto_var}
+    endif
+
+    " Parse and extract the tag prototype
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let tag_proto = strpart(tag_line, start, end - start)
+    let {tproto_var} = substitute(tag_proto, '\s*', '', '')
+
+    return {tproto_var}
+endfunction
+
+" Tlist_Get_Tag_SearchPat
+function! s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+    let tpat_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_searchpat'
+
+    " Already parsed and have the tag search pattern
+    if exists(tpat_var)
+        return {tpat_var}
+    endif
+
+    " Parse and extract the tag search pattern
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = stridx(tag_line, '/^') + 2
+    let end = stridx(tag_line, '/;"' . "\t")
+    if tag_line[end - 1] == '$'
+        let end = end -1
+    endif
+    let {tpat_var} = '\V\^' . strpart(tag_line, start, end - start) .
+                        \ (tag_line[end] == '$' ? '\$' : '')
+
+    return {tpat_var}
+endfunction
+
+" Tlist_Get_Tag_Linenum
+" Return the tag line number, given the tag index
+function! s:Tlist_Get_Tag_Linenum(fidx, tidx)
+    let tline_var = 's:tlist_' . a:fidx . '_' . a:tidx . '_tag_linenum'
+
+    " Already parsed and have the tag line number
+    if exists(tline_var)
+        return {tline_var}
+    endif
+
+    " Parse and extract the tag line number
+    let tag_line = s:tlist_{a:fidx}_{a:tidx}_tag
+    let start = strridx(tag_line, 'line:') + 5
+    let end = strridx(tag_line, "\t")
+    if end < start
+        let {tline_var} = strpart(tag_line, start) + 0
+    else
+        let {tline_var} = strpart(tag_line, start, end - start) + 0
+    endif
+
+    return {tline_var}
+endfunction
+
+" Tlist_Parse_Tagline
+" Parse a tag line from the ctags output. Separate the tag output based on the
+" tag type and store it in the tag type variable.
+" The format of each line in the ctags output is:
+"
+"     tag_name<TAB>file_name<TAB>ex_cmd;"<TAB>extension_fields
+"
+function! s:Tlist_Parse_Tagline(tag_line)
+    if a:tag_line == ''
+        " Skip empty lines
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Extract_Tagtype(a:tag_line)
+
+    " Make sure the tag type is a valid and supported one
+    if ttype == '' || stridx(s:ctags_flags, ttype) == -1
+        " Line is not in proper tags format or Tag type is not supported
+        return
+    endif
+
+    " Update the total tag count
+    let s:tidx = s:tidx + 1
+
+    " The following variables are used to optimize this code.  Vim is slow in
+    " using curly brace names. To reduce the amount of processing needed, the
+    " curly brace variables are pre-processed here
+    let fidx_tidx = 's:tlist_' . s:fidx . '_' . s:tidx
+    let fidx_ttype = 's:tlist_' . s:fidx . '_' . ttype
+
+    " Update the count of this tag type
+    let ttype_idx = {fidx_ttype}_count + 1
+    let {fidx_ttype}_count = ttype_idx
+
+    " Store the ctags output for this tag
+    let {fidx_tidx}_tag = a:tag_line
+
+    " Store the tag index and the tag type index (back pointers)
+    let {fidx_ttype}_{ttype_idx} = s:tidx
+    let {fidx_tidx}_ttype_idx = ttype_idx
+
+    " Extract the tag name
+    let tag_name = strpart(a:tag_line, 0, stridx(a:tag_line, "\t"))
+
+    " Extract the tag scope/prototype
+    if g:Tlist_Display_Prototype
+        let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(s:fidx, s:tidx)
+    else
+        let ttxt = '    ' . tag_name
+
+        " Add the tag scope, if it is available and is configured. Tag
+        " scope is the last field after the 'line:<num>\t' field
+        if g:Tlist_Display_Tag_Scope
+            let tag_scope = s:Tlist_Extract_Tag_Scope(a:tag_line)
+            if tag_scope != ''
+                let ttxt = ttxt . ' [' . tag_scope . ']'
+            endif
+        endif
+    endif
+
+    " Add this tag to the tag type variable
+    let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+    " Save the tag name
+    let {fidx_tidx}_tag_name = tag_name
+endfunction
+
+" Tlist_Process_File
+" Get the list of tags defined in the specified file and store them
+" in Vim variables. Returns the file index where the tags are stored.
+function! s:Tlist_Process_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Process_File (' . a:filename . ', ' .
+                \ a:ftype . ')')
+    " Check whether this file is supported
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return -1
+    endif
+
+    " If the tag types for this filetype are not yet created, then create
+    " them now
+    let var = 's:tlist_' . a:ftype . '_count'
+    if !exists(var)
+        if s:Tlist_FileType_Init(a:ftype) == 0
+            return -1
+        endif
+    endif
+
+    " If this file is already processed, then use the cached values
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " First time, this file is loaded
+        let fidx = s:Tlist_Init_File(a:filename, a:ftype)
+    else
+        " File was previously processed. Discard the tag information
+        call s:Tlist_Discard_TagInfo(fidx)
+    endif
+
+    let s:tlist_{fidx}_valid = 1
+
+    " Exuberant ctags arguments to generate a tag list
+    let ctags_args = ' -f - --format=2 --excmd=pattern --fields=nks '
+
+    " Form the ctags argument depending on the sort type
+    if s:tlist_{fidx}_sort_type == 'name'
+        let ctags_args = ctags_args . '--sort=yes'
+    else
+        let ctags_args = ctags_args . '--sort=no'
+    endif
+
+    " Add the filetype specific arguments
+    let ctags_args = ctags_args . ' ' . s:tlist_{a:ftype}_ctags_args
+
+    " Ctags command to produce output with regexp for locating the tags
+    let ctags_cmd = g:Tlist_Ctags_Cmd . ctags_args
+    let ctags_cmd = ctags_cmd . ' "' . a:filename . '"'
+
+    if &shellxquote == '"'
+        " Double-quotes within double-quotes will not work in the
+        " command-line.If the 'shellxquote' option is set to double-quotes,
+        " then escape the double-quotes in the ctags command-line.
+        let ctags_cmd = escape(ctags_cmd, '"')
+    endif
+
+    " In Windows 95, if not using cygwin, disable the 'shellslash'
+    " option. Otherwise, this will cause problems when running the
+    " ctags command.
+    if has('win95') && !has('win32unix')
+        let old_shellslash = &shellslash
+        set noshellslash
+    endif
+
+    if has('win32') && !has('win32unix') && !has('win95')
+                \ && (&shell =~ 'cmd.exe')
+        " Windows does not correctly deal with commands that have more than 1
+        " set of double quotes.  It will strip them all resulting in:
+        " 'C:\Program' is not recognized as an internal or external command
+        " operable program or batch file.  To work around this, place the
+        " command inside a batch file and call the batch file.
+        " Do this only on Win2K, WinXP and above.
+        " Contributed by: David Fishburn.
+        let s:taglist_tempfile = fnamemodify(tempname(), ':h') .
+                    \ '\taglist.cmd'
+        exe 'redir! > ' . s:taglist_tempfile
+        silent echo ctags_cmd
+        redir END
+
+        call s:Tlist_Log_Msg('Cmd inside batch file: ' . ctags_cmd)
+        let ctags_cmd = '"' . s:taglist_tempfile . '"'
+    endif
+
+    call s:Tlist_Log_Msg('Cmd: ' . ctags_cmd)
+
+    " Run ctags and get the tag list
+    let cmd_output = system(ctags_cmd)
+
+    " Restore the value of the 'shellslash' option.
+    if has('win95') && !has('win32unix')
+        let &shellslash = old_shellslash
+    endif
+
+    if exists('s:taglist_tempfile')
+        " Delete the temporary cmd file created on MS-Windows
+        call delete(s:taglist_tempfile)
+    endif
+
+    " Handle errors
+    if v:shell_error
+        let msg = "Taglist: Failed to generate tags for " . a:filename
+        call s:Tlist_Warning_Msg(msg)
+        if cmd_output != ''
+            call s:Tlist_Warning_Msg(cmd_output)
+        endif
+        return fidx
+    endif
+
+    " Store the modification time for the file
+    let s:tlist_{fidx}_mtime = getftime(a:filename)
+
+    " No tags for current file
+    if cmd_output == ''
+        call s:Tlist_Log_Msg('No tags defined in ' . a:filename)
+        return fidx
+    endif
+
+    call s:Tlist_Log_Msg('Generated tags information for ' . a:filename)
+
+    if v:version > 601
+        " The following script local variables are used by the
+        " Tlist_Parse_Tagline() function.
+        let s:ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let s:fidx = fidx
+        let s:tidx = 0
+
+        " Process the ctags output one line at a time.  The substitute()
+        " command is used to parse the tag lines instead of using the
+        " matchstr()/stridx()/strpart() functions for performance reason
+        call substitute(cmd_output, "\\([^\n]\\+\\)\n",
+                    \ '\=s:Tlist_Parse_Tagline(submatch(1))', 'g')
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = s:tidx
+
+        " The following script local variables are no longer needed
+        unlet! s:ctags_flags
+        unlet! s:tidx
+        unlet! s:fidx
+    else
+        " Due to a bug in Vim earlier than version 6.1,
+        " we cannot use substitute() to parse the ctags output.
+        " Instead the slow str*() functions are used
+        let ctags_flags = s:tlist_{a:ftype}_ctags_flags
+        let tidx = 0
+
+        while cmd_output != ''
+            " Extract one line at a time
+            let idx = stridx(cmd_output, "\n")
+            let one_line = strpart(cmd_output, 0, idx)
+            " Remove the line from the tags output
+            let cmd_output = strpart(cmd_output, idx + 1)
+
+            if one_line == ''
+                " Line is not in proper tags format
+                continue
+            endif
+
+            " Extract the tag type
+            let ttype = s:Tlist_Extract_Tagtype(one_line)
+
+            " Make sure the tag type is a valid and supported one
+            if ttype == '' || stridx(ctags_flags, ttype) == -1
+                " Line is not in proper tags format or Tag type is not
+                " supported
+                continue
+            endif
+
+            " Update the total tag count
+            let tidx = tidx + 1
+
+            " The following variables are used to optimize this code.  Vim is
+            " slow in using curly brace names. To reduce the amount of
+            " processing needed, the curly brace variables are pre-processed
+            " here
+            let fidx_tidx = 's:tlist_' . fidx . '_' . tidx
+            let fidx_ttype = 's:tlist_' . fidx . '_' . ttype
+
+            " Update the count of this tag type
+            let ttype_idx = {fidx_ttype}_count + 1
+            let {fidx_ttype}_count = ttype_idx
+
+            " Store the ctags output for this tag
+            let {fidx_tidx}_tag = one_line
+
+            " Store the tag index and the tag type index (back pointers)
+            let {fidx_ttype}_{ttype_idx} = tidx
+            let {fidx_tidx}_ttype_idx = ttype_idx
+
+            " Extract the tag name
+            let tag_name = strpart(one_line, 0, stridx(one_line, "\t"))
+
+            " Extract the tag scope/prototype
+            if g:Tlist_Display_Prototype
+                let ttxt = '    ' . s:Tlist_Get_Tag_Prototype(fidx, tidx)
+            else
+                let ttxt = '    ' . tag_name
+
+                " Add the tag scope, if it is available and is configured. Tag
+                " scope is the last field after the 'line:<num>\t' field
+                if g:Tlist_Display_Tag_Scope
+                    let tag_scope = s:Tlist_Extract_Tag_Scope(one_line)
+                    if tag_scope != ''
+                        let ttxt = ttxt . ' [' . tag_scope . ']'
+                    endif
+                endif
+            endif
+
+            " Add this tag to the tag type variable
+            let {fidx_ttype} = {fidx_ttype} . ttxt . "\n"
+
+            " Save the tag name
+            let {fidx_tidx}_tag_name = tag_name
+        endwhile
+
+        " Save the number of tags for this file
+        let s:tlist_{fidx}_tag_count = tidx
+    endif
+
+    call s:Tlist_Log_Msg('Processed ' . s:tlist_{fidx}_tag_count . 
+                \ ' tags in ' . a:filename)
+
+    return fidx
+endfunction
+
+" Tlist_Update_File
+" Update the tags for a file (if needed)
+function! Tlist_Update_File(filename, ftype)
+    call s:Tlist_Log_Msg('Tlist_Update_File (' . a:filename . ')')
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(a:filename, a:ftype)
+        return
+    endif
+
+    " Convert the file name to a full path
+    let fname = fnamemodify(a:filename, ':p')
+
+    " First check whether the file already exists
+    let fidx = s:Tlist_Get_File_Index(fname)
+
+    if fidx != -1 && s:tlist_{fidx}_valid
+        " File exists and the tags are valid
+        " Check whether the file was modified after the last tags update
+        " If it is modified, then update the tags
+        if s:tlist_{fidx}_mtime == getftime(fname)
+            return
+        endif
+    else
+        " If the tags were removed previously based on a user request,
+        " as we are going to update the tags (based on the user request),
+        " remove the filename from the deleted list
+        call s:Tlist_Update_Remove_List(fname, 0)
+    endif
+
+    " If the taglist window is opened, update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        " Taglist window is not present. Just update the taglist
+        " and return
+        call s:Tlist_Process_File(fname, a:ftype)
+    else
+        if g:Tlist_Show_One_File && s:tlist_cur_file_idx != -1
+            " If tags for only one file are displayed and we are not
+            " updating the tags for that file, then no need to
+            " refresh the taglist window. Otherwise, the taglist
+            " window should be updated.
+            if s:tlist_{s:tlist_cur_file_idx}_filename != fname
+                call s:Tlist_Process_File(fname, a:ftype)
+                return
+            endif
+        endif
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Save the cursor position
+        let save_line = line('.')
+        let save_col = col('.')
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(fname, a:ftype)
+
+        " Restore the cursor position
+        if v:version >= 601
+            call cursor(save_line, save_col)
+        else
+            exe save_line
+            exe 'normal! ' . save_col . '|'
+        endif
+
+        if winnr() != save_winnr
+            " Go back to the original window
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(1)
+    endif
+endfunction
+
+" Tlist_Window_Close
+" Close the taglist window
+function! s:Tlist_Window_Close()
+    call s:Tlist_Log_Msg('Tlist_Window_Close()')
+    " Make sure the taglist window exists
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    if winnr() == winnum
+        " Already in the taglist window. Close it and return
+        if winbufnr(2) != -1
+            " If a window other than the taglist window is open,
+            " then only close the taglist window.
+            close
+        endif
+    else
+        " Goto the taglist window, close it and then come back to the
+        " original window
+        let curbufnr = bufnr('%')
+        exe winnum . 'wincmd w'
+        close
+        " Need to jump back to the original window only if we are not
+        " already in that window
+        let winnum = bufwinnr(curbufnr)
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+    endif
+endfunction
+
+" Tlist_Window_Mark_File_Window
+" Mark the current window as the file window to use when jumping to a tag.
+" Only if the current window is a non-plugin, non-preview and non-taglist
+" window
+function! s:Tlist_Window_Mark_File_Window()
+    if getbufvar('%', '&buftype') == '' && !&previewwindow
+        let w:tlist_file_window = "yes"
+    endif
+endfunction
+
+" Tlist_Window_Open
+" Open and refresh the taglist window
+function! s:Tlist_Window_Open()
+    call s:Tlist_Log_Msg('Tlist_Window_Open()')
+    " If the window is open, jump to it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        " Jump to the existing window
+        if winnr() != winnum
+            exe winnum . 'wincmd w'
+        endif
+        return
+    endif
+
+    if s:tlist_app_name == "winmanager"
+        " Taglist plugin is no longer part of the winmanager app
+        let s:tlist_app_name = "none"
+    endif
+
+    " Get the filename and filetype for the specified buffer
+    let curbuf_name = fnamemodify(bufname('%'), ':p')
+    let curbuf_ftype = getbufvar('%', '&filetype')
+    let cur_lnum = line('.')
+
+    " Mark the current window as the desired window to open a file when a tag
+    " is selected.
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Open the taglist window
+    call s:Tlist_Window_Create()
+
+    call s:Tlist_Window_Refresh()
+
+    if g:Tlist_Show_One_File
+        " Add only the current buffer and file
+        "
+        " If the file doesn't support tag listing, skip it
+        if !s:Tlist_Skip_File(curbuf_name, curbuf_ftype)
+            call s:Tlist_Window_Refresh_File(curbuf_name, curbuf_ftype)
+        endif
+    endif
+
+    if g:Tlist_File_Fold_Auto_Close
+        " Open the fold for the current file, as all the folds in
+        " the taglist window are closed
+        let fidx = s:Tlist_Get_File_Index(curbuf_name)
+        if fidx != -1
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen!"
+        endif
+    endif
+
+    " Highlight the current tag
+    call s:Tlist_Window_Highlight_Tag(curbuf_name, cur_lnum, 1, 1)
+endfunction
+
+" Tlist_Window_Toggle()
+" Open or close a taglist window
+function! s:Tlist_Window_Toggle()
+    call s:Tlist_Log_Msg('Tlist_Window_Toggle()')
+    " If taglist window is open then close it.
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        call s:Tlist_Window_Close()
+        return
+    endif
+
+    call s:Tlist_Window_Open()
+
+    " Go back to the original window, if Tlist_GainFocus_On_ToggleOpen is not
+    " set
+    if !g:Tlist_GainFocus_On_ToggleOpen
+        call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Process_Filelist
+" Process multiple files. Each filename is separated by "\n"
+" Returns the number of processed files
+function! s:Tlist_Process_Filelist(file_names)
+    let flist = a:file_names
+
+    " Enable lazy screen updates
+    let old_lazyredraw = &lazyredraw
+    set lazyredraw
+
+    " Keep track of the number of processed files
+    let fcnt = 0
+
+    " Process one file at a time
+    while flist != ''
+        let nl_idx = stridx(flist, "\n")
+        let one_file = strpart(flist, 0, nl_idx)
+
+        " Remove the filename from the list
+        let flist = strpart(flist, nl_idx + 1)
+
+        if one_file == ''
+            continue
+        endif
+
+        " Skip directories
+        if isdirectory(one_file)
+            continue
+        endif
+
+        let ftype = s:Tlist_Get_Filetype(one_file)
+
+        echon "\r                                                              "
+        echon "\rProcessing tags for " . fnamemodify(one_file, ':p:t')
+
+        let fcnt = fcnt + 1
+
+        call Tlist_Update_File(one_file, ftype)
+    endwhile
+
+    " Clear the displayed informational messages
+    echon "\r                                                            "
+
+    " Restore the previous state
+    let &lazyredraw = old_lazyredraw
+
+    return fcnt
+endfunction
+
+" Tlist_Process_Dir
+" Process the files in a directory matching the specified pattern
+function! s:Tlist_Process_Dir(dir_name, pat)
+    let flist = glob(a:dir_name . '/' . a:pat) . "\n"
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+
+    let len = strlen(a:dir_name)
+    if a:dir_name[len - 1] == '\' || a:dir_name[len - 1] == '/'
+        let glob_expr = a:dir_name . '*'
+    else
+        let glob_expr = a:dir_name . '/*'
+    endif
+    let all_files = glob(glob_expr) . "\n"
+
+    while all_files != ''
+        let nl_idx = stridx(all_files, "\n")
+        let one_file = strpart(all_files, 0, nl_idx)
+
+        let all_files = strpart(all_files, nl_idx + 1)
+        if one_file == ''
+            continue
+        endif
+
+        " Skip non-directory names
+        if !isdirectory(one_file)
+            continue
+        endif
+
+        echon "\r                                                              "
+        echon "\rProcessing files in directory " . fnamemodify(one_file, ':t')
+        let fcnt = fcnt + s:Tlist_Process_Dir(one_file, a:pat)
+    endwhile
+
+    return fcnt
+endfunction
+
+" Tlist_Add_Files_Recursive
+" Add files recursively from a directory
+function! s:Tlist_Add_Files_Recursive(dir, ...)
+    let dir_name = fnamemodify(a:dir, ':p')
+    if !isdirectory(dir_name)
+        call s:Tlist_Warning_Msg('Error: ' . dir_name . ' is not a directory')
+        return
+    endif
+
+    if a:0 == 1
+        " User specified file pattern
+        let pat = a:1
+    else
+        " Default file pattern
+        let pat = '*'
+    endif
+
+    echon "\r                                                              "
+    echon "\rProcessing files in directory " . fnamemodify(dir_name, ':t')
+    let fcnt = s:Tlist_Process_Dir(dir_name, pat)
+
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Add_Files
+" Add the specified list of files to the taglist
+function! s:Tlist_Add_Files(...)
+    let flist = ''
+    let i = 1
+
+    " Get all the files matching the file patterns supplied as argument
+    while i <= a:0
+        let flist = flist . glob(a:{i}) . "\n"
+        let i = i + 1
+    endwhile
+
+    if flist == ''
+        call s:Tlist_Warning_Msg('Error: No matching files are found')
+        return
+    endif
+
+    let fcnt = s:Tlist_Process_Filelist(flist)
+    echon "\rAdded " . fcnt . " files to the taglist"
+endfunction
+
+" Tlist_Extract_Tagtype
+" Extract the tag type from the tag text
+function! s:Tlist_Extract_Tagtype(tag_line)
+    " The tag type is after the tag prototype field. The prototype field
+    " ends with the /;"\t string. We add 4 at the end to skip the characters
+    " in this special string..
+    let start = strridx(a:tag_line, '/;"' . "\t") + 4
+    let end = strridx(a:tag_line, 'line:') - 1
+    let ttype = strpart(a:tag_line, start, end - start)
+
+    return ttype
+endfunction
+
+" Tlist_Extract_Tag_Scope
+" Extract the tag scope from the tag text
+function! s:Tlist_Extract_Tag_Scope(tag_line)
+    let start = strridx(a:tag_line, 'line:')
+    let end = strridx(a:tag_line, "\t")
+    if end <= start
+        return ''
+    endif
+
+    let tag_scope = strpart(a:tag_line, end + 1)
+    let tag_scope = strpart(tag_scope, stridx(tag_scope, ':') + 1)
+
+    return tag_scope
+endfunction
+
+" Tlist_Refresh()
+" Refresh the taglist
+function! s:Tlist_Refresh()
+    call s:Tlist_Log_Msg('Tlist_Refresh (Skip_Refresh = ' .
+                \ s:Tlist_Skip_Refresh . ', ' . bufname('%') . ')')
+    " If we are entering the buffer from one of the taglist functions, then
+    " no need to refresh the taglist window again.
+    if s:Tlist_Skip_Refresh
+        " We still need to update the taglist menu
+        if g:Tlist_Show_Menu
+            call s:Tlist_Menu_Update_File(0)
+        endif
+        return
+    endif
+
+    " If part of the winmanager plugin and not configured to process
+    " tags always and not configured to display the tags menu, then return
+    if (s:tlist_app_name == 'winmanager') && !g:Tlist_Process_File_Always
+                \ && !g:Tlist_Show_Menu
+        return
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = &filetype
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let tlist_win = bufwinnr(g:TagList_title)
+
+    " If the taglist window is not opened and not configured to process
+    " tags always and not displaying the tags menu, then return
+    if tlist_win == -1 && !g:Tlist_Process_File_Always && !g:Tlist_Show_Menu
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " If the taglist should not be auto updated, then return
+        if !g:Tlist_Auto_Update
+            return
+        endif
+    endif
+
+    let cur_lnum = line('.')
+
+    if fidx == -1
+        " Update the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+    else
+        let mtime = getftime(filename)
+        if s:tlist_{fidx}_mtime != mtime
+            " Invalidate the tags listed for this file
+            let s:tlist_{fidx}_valid = 0
+
+            " Update the taglist and the window
+            call Tlist_Update_File(filename, ftype)
+
+            " Store the new file modification time
+            let s:tlist_{fidx}_mtime = mtime
+        endif
+    endif
+
+    " Update the taglist window
+    if tlist_win != -1
+        " Disable screen updates
+        let old_lazyredraw = &lazyredraw
+        set nolazyredraw
+
+        " Save the current window number
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        if !g:Tlist_Auto_Highlight_Tag || !g:Tlist_Highlight_Tag_On_BufEnter
+            " Save the cursor position
+            let save_line = line('.')
+            let save_col = col('.')
+        endif
+
+        " Update the taglist window
+        call s:Tlist_Window_Refresh_File(filename, ftype)
+
+        " Open the fold for the file
+        exe "silent! " . s:tlist_{fidx}_start . "," .
+                    \ s:tlist_{fidx}_end . "foldopen!"
+
+        if g:Tlist_Highlight_Tag_On_BufEnter && g:Tlist_Auto_Highlight_Tag
+            if g:Tlist_Show_One_File && s:tlist_cur_file_idx != fidx
+                " If displaying tags for only one file in the taglist
+                " window and about to display the tags for a new file,
+                " then center the current tag line for the new file
+                let center_tag_line = 1
+            else
+                let center_tag_line = 0
+            endif
+
+            " Highlight the current tag
+            call s:Tlist_Window_Highlight_Tag(filename, cur_lnum, 1, center_tag_line)
+        else
+            " Restore the cursor position
+            if v:version >= 601
+                call cursor(save_line, save_col)
+            else
+                exe save_line
+                exe 'normal! ' . save_col . '|'
+            endif
+        endif
+
+        " Jump back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds(save_winnr . 'wincmd w')
+        endif
+
+        " Restore screen updates
+        let &lazyredraw = old_lazyredraw
+    endif
+
+    " Update the taglist menu
+    if g:Tlist_Show_Menu
+        call s:Tlist_Menu_Update_File(0)
+    endif
+endfunction
+
+" Tlist_Change_Sort()
+" Change the sort order of the tag listing
+" caller == 'cmd', command used in the taglist window
+" caller == 'menu', taglist menu
+" action == 'toggle', toggle sort from name to order and vice versa
+" action == 'set', set the sort order to sort_type
+function! s:Tlist_Change_Sort(caller, action, sort_type)
+    call s:Tlist_Log_Msg('Tlist_Change_Sort (caller = ' . a:caller .
+            \ ', action = ' . a:action . ', sort_type = ' . a:sort_type . ')')
+    if a:caller == 'cmd'
+        let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+        if fidx == -1
+            return
+        endif
+
+        " Remove the previous highlighting
+        match none
+    elseif a:caller == 'menu'
+        let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if a:action == 'toggle'
+        let sort_type = s:tlist_{fidx}_sort_type
+
+        " Toggle the sort order from 'name' to 'order' and vice versa
+        if sort_type == 'name'
+            let s:tlist_{fidx}_sort_type = 'order'
+        else
+            let s:tlist_{fidx}_sort_type = 'name'
+        endif
+    else
+        let s:tlist_{fidx}_sort_type = a:sort_type
+    endif
+
+    " Invalidate the tags listed for this file
+    let s:tlist_{fidx}_valid = 0
+
+    if a:caller  == 'cmd'
+        " Save the current line for later restoration
+        let curline = '\V\^' . getline('.') . '\$'
+
+        call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                    \   s:tlist_{fidx}_filetype)
+
+        exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+        " Go back to the cursor line before the tag list is sorted
+        call search(curline, 'w')
+
+        call s:Tlist_Menu_Update_File(1)
+    else
+        call s:Tlist_Menu_Remove_File()
+
+        call s:Tlist_Refresh()
+    endif
+endfunction
+
+" Tlist_Update_Current_File()
+" Update taglist for the current buffer by regenerating the tag list
+" Contributed by WEN Guopeng.
+function! s:Tlist_Update_Current_File()
+    call s:Tlist_Log_Msg('Tlist_Update_Current_File()')
+    if winnr() == bufwinnr(g:TagList_title)
+        " In the taglist window. Update the current file
+        call s:Tlist_Window_Update_File()
+    else
+        " Not in the taglist window. Update the current buffer
+        let filename = fnamemodify(bufname('%'), ':p')
+        let fidx = s:Tlist_Get_File_Index(filename)
+        if fidx != -1
+            let s:tlist_{fidx}_valid = 0
+        endif
+        call Tlist_Update_File(filename, &filetype)
+    endif
+endfunction
+
+" Tlist_Window_Update_File()
+" Update the tags displayed in the taglist window
+function! s:Tlist_Window_Update_File()
+    call s:Tlist_Log_Msg('Tlist_Window_Update_File()')
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    " Remove the previous highlighting
+    match none
+
+    " Save the current line for later restoration
+    let curline = '\V\^' . getline('.') . '\$'
+
+    let s:tlist_{fidx}_valid = 0
+
+    " Update the taglist window
+    call s:Tlist_Window_Refresh_File(s:tlist_{fidx}_filename,
+                \ s:tlist_{fidx}_filetype)
+
+    exe s:tlist_{fidx}_start . ',' . s:tlist_{fidx}_end . 'foldopen!'
+
+    " Go back to the tag line before the list is updated
+    call search(curline, 'w')
+endfunction
+
+" Tlist_Window_Get_Tag_Type_By_Linenum()
+" Return the tag type index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+    let ftype = s:tlist_{a:fidx}_filetype
+
+    " Determine to which tag type the current line number belongs to using the
+    " tag type start line number and the number of tags in a tag type
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let ttype = s:tlist_{ftype}_{i}_name
+        let start_lnum =
+                    \ s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+        let end =  start_lnum + s:tlist_{a:fidx}_{ttype}_count
+        if a:lnum >= start_lnum && a:lnum <= end
+            break
+        endif
+        let i = i + 1
+    endwhile
+
+    " Current line doesn't belong to any of the displayed tag types
+    if i > s:tlist_{ftype}_count
+        return ''
+    endif
+
+    return ttype
+endfunction
+
+" Tlist_Window_Get_Tag_Index()
+" Return the tag index for the specified line in the taglist window
+function! s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(a:fidx, a:lnum)
+
+    " Current line doesn't belong to any of the displayed tag types
+    if ttype == ''
+        return 0
+    endif
+
+    " Compute the index into the displayed tags for the tag type
+    let ttype_lnum = s:tlist_{a:fidx}_start + s:tlist_{a:fidx}_{ttype}_offset
+    let tidx = a:lnum - ttype_lnum
+    if tidx == 0
+        return 0
+    endif
+
+    " Get the corresponding tag line and return it
+    return s:tlist_{a:fidx}_{ttype}_{tidx}
+endfunction
+
+" Tlist_Window_Highlight_Line
+" Highlight the current line
+function! s:Tlist_Window_Highlight_Line()
+    " Clear previously selected name
+    match none
+
+    " Highlight the current line
+    if g:Tlist_Display_Prototype == 0
+        let pat = '/\%' . line('.') . 'l\s\+\zs.*/'
+    else
+        let pat = '/\%' . line('.') . 'l.*/'
+    endif
+
+    exe 'match TagListTagName ' . pat
+endfunction
+
+" Tlist_Window_Open_File
+" Open the specified file in either a new window or an existing window
+" and place the cursor at the specified tag pattern
+function! s:Tlist_Window_Open_File(win_ctrl, filename, tagpat)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File (' . a:filename . ',' .
+                \ a:win_ctrl . ')')
+    let prev_Tlist_Skip_Refresh = s:Tlist_Skip_Refresh
+    let s:Tlist_Skip_Refresh = 1
+
+    if s:tlist_app_name == "winmanager"
+        " Let the winmanager edit the file
+        call WinManagerFileEdit(a:filename, a:win_ctrl == 'newwin')
+    else
+
+    if a:win_ctrl == 'newtab'
+        " Create a new tab
+        exe 'tabnew ' . escape(a:filename, ' ')
+        " Open the taglist window in the new tab
+        call s:Tlist_Window_Open()
+    endif
+
+    if a:win_ctrl == 'checktab'
+        " Check whether the file is present in any of the tabs.
+        " If the file is present in the current tab, then use the
+        " current tab.
+        if bufwinnr(a:filename) != -1
+            let file_present_in_tab = 1
+            let i = tabpagenr()
+        else
+            let i = 1
+            let bnum = bufnr(a:filename)
+            let file_present_in_tab = 0
+            while i <= tabpagenr('$')
+                if index(tabpagebuflist(i), bnum) != -1
+                    let file_present_in_tab = 1
+                    break
+                endif
+                let i += 1
+            endwhile
+        endif
+
+        if file_present_in_tab
+            " Goto the tab containing the file
+            exe 'tabnext ' . i
+        else
+            " Open a new tab
+            exe 'tabnew ' . escape(a:filename, ' ')
+
+            " Open the taglist window
+            call s:Tlist_Window_Open()
+        endif
+    endif
+
+    let winnum = -1
+    if a:win_ctrl == 'prevwin'
+        " Open the file in the previous window, if it is usable
+        let cur_win = winnr()
+        wincmd p
+        if &buftype == '' && !&previewwindow
+            exe "edit " . escape(a:filename, ' ')
+            let winnum = winnr()
+        else
+            " Previous window is not usable
+            exe cur_win . 'wincmd w'
+        endif
+    endif
+
+    " Goto the window containing the file.  If the window is not there, open a
+    " new window
+    if winnum == -1
+        let winnum = bufwinnr(a:filename)
+    endif
+
+    if winnum == -1
+        " Locate the previously used window for opening a file
+        let fwin_num = 0
+        let first_usable_win = 0
+
+        let i = 1
+        let bnum = winbufnr(i)
+        while bnum != -1
+            if getwinvar(i, 'tlist_file_window') == 'yes'
+                let fwin_num = i
+                break
+            endif
+            if first_usable_win == 0 &&
+                        \ getbufvar(bnum, '&buftype') == '' &&
+                        \ !getwinvar(i, '&previewwindow')
+                " First non-taglist, non-plugin and non-preview window
+                let first_usable_win = i
+            endif
+            let i = i + 1
+            let bnum = winbufnr(i)
+        endwhile
+
+        " If a previously used window is not found, then use the first
+        " non-taglist window
+        if fwin_num == 0
+            let fwin_num = first_usable_win
+        endif
+
+        if fwin_num != 0
+            " Jump to the file window
+            exe fwin_num . "wincmd w"
+
+            " If the user asked to jump to the tag in a new window, then split
+            " the existing window into two.
+            if a:win_ctrl == 'newwin'
+                split
+            endif
+            exe "edit " . escape(a:filename, ' ')
+        else
+            " Open a new window
+            if g:Tlist_Use_Horiz_Window
+                exe 'leftabove split ' . escape(a:filename, ' ')
+            else
+                if winbufnr(2) == -1
+                    " Only the taglist window is present
+                    if g:Tlist_Use_Right_Window
+                        exe 'leftabove vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    else
+                        exe 'rightbelow vertical split ' .
+                                    \ escape(a:filename, ' ')
+                    endif
+
+                    " Go to the taglist window to change the window size to
+                    " the user configured value
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                    if g:Tlist_Use_Horiz_Window
+                        exe 'resize ' . g:Tlist_WinHeight
+                    else
+                        exe 'vertical resize ' . g:Tlist_WinWidth
+                    endif
+                    " Go back to the file window
+                    call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+                else
+                    " A plugin or help window is also present
+                    wincmd w
+                    exe 'leftabove split ' . escape(a:filename, ' ')
+                endif
+            endif
+        endif
+        " Mark the window, so that it can be reused.
+        call s:Tlist_Window_Mark_File_Window()
+    else
+        if v:version >= 700
+            " If the file is opened in more than one window, then check
+            " whether the last accessed window has the selected file.
+            " If it does, then use that window.
+            let lastwin_bufnum = winbufnr(winnr('#'))
+            if bufnr(a:filename) == lastwin_bufnum
+                let winnum = winnr('#')
+            endif
+        endif
+        exe winnum . 'wincmd w'
+
+        " If the user asked to jump to the tag in a new window, then split the
+        " existing window into two.
+        if a:win_ctrl == 'newwin'
+            split
+        endif
+    endif
+    endif
+
+    " Jump to the tag
+    if a:tagpat != ''
+        " Add the current cursor position to the jump list, so that user can
+        " jump back using the ' and ` marks.
+        mark '
+        silent call search(a:tagpat, 'w')
+
+        " Bring the line to the middle of the window
+        normal! z.
+
+        " If the line is inside a fold, open the fold
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+    endif
+
+    " If the user selects to preview the tag then jump back to the
+    " taglist window
+    if a:win_ctrl == 'preview'
+        " Go back to the taglist window
+        let winnum = bufwinnr(g:TagList_title)
+        exe winnum . 'wincmd w'
+    else
+        " If the user has selected to close the taglist window, when a
+        " tag is selected, close the taglist  window
+        if g:Tlist_Close_On_Select
+            call s:Tlist_Window_Goto_Window()
+            close
+
+            " Go back to the window displaying the selected file
+            let wnum = bufwinnr(a:filename)
+            if wnum != -1 && wnum != winnr()
+                call s:Tlist_Exe_Cmd_No_Acmds(wnum . 'wincmd w')
+            endif
+        endif
+    endif
+
+    let s:Tlist_Skip_Refresh = prev_Tlist_Skip_Refresh
+endfunction
+
+" Tlist_Window_Jump_To_Tag()
+" Jump to the location of the current tag
+" win_ctrl == useopen - Reuse the existing file window
+" win_ctrl == newwin - Open a new window
+" win_ctrl == preview - Preview the tag
+" win_ctrl == prevwin - Open in previous window
+" win_ctrl == newtab - Open in new tab
+function! s:Tlist_Window_Jump_To_Tag(win_ctrl)
+    call s:Tlist_Log_Msg('Tlist_Window_Jump_To_Tag(' . a:win_ctrl . ')')
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a closed fold, then use the first line of the fold
+    " and jump to the file.
+    let lnum = foldclosed('.')
+    if lnum == -1
+        " Jump to the selected tag or file
+        let lnum = line('.')
+    else
+        " Open the closed fold
+        .foldopen!
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    " Get the tag output for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx != 0
+        let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, tidx)
+
+        " Highlight the tagline
+        call s:Tlist_Window_Highlight_Line()
+    else
+        " Selected a line which is not a tag name. Just edit the file
+        let tagpat = ''
+    endif
+
+    call s:Tlist_Window_Open_File(a:win_ctrl, s:tlist_{fidx}_filename, tagpat)
+endfunction
+
+" Tlist_Window_Show_Info()
+" Display information about the entry under the cursor
+function! s:Tlist_Window_Show_Info()
+    call s:Tlist_Log_Msg('Tlist_Window_Show_Info()')
+
+    " Clear the previously displayed line
+    echo
+
+    " Do not process comment lines and empty lines
+    let curline = getline('.')
+    if curline =~ '^\s*$' || curline[0] == '"'
+        return
+    endif
+
+    " If inside a fold, then don't display the prototype
+    if foldclosed('.') != -1
+        return
+    endif
+
+    let lnum = line('.')
+
+    " Get the file index
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(lnum)
+    if fidx == -1
+        return
+    endif
+
+    if lnum == s:tlist_{fidx}_start
+        " Cursor is on a file name
+        let fname = s:tlist_{fidx}_filename
+        if strlen(fname) > 50
+            let fname = fnamemodify(fname, ':t')
+        endif
+        echo fname . ', Filetype=' . s:tlist_{fidx}_filetype .
+                    \  ', Tag count=' . s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    " Get the tag output line for the current tag
+    let tidx = s:Tlist_Window_Get_Tag_Index(fidx, lnum)
+    if tidx == 0
+        " Cursor is on a tag type
+        let ttype = s:Tlist_Window_Get_Tag_Type_By_Linenum(fidx, lnum)
+        if ttype == ''
+            return
+        endif
+
+        let ttype_name = ''
+
+        let ftype = s:tlist_{fidx}_filetype
+        let i = 1
+        while i <= s:tlist_{ftype}_count
+            if ttype == s:tlist_{ftype}_{i}_name
+                let ttype_name = s:tlist_{ftype}_{i}_fullname
+                break
+            endif
+            let i = i + 1
+        endwhile
+
+        echo 'Tag type=' . ttype_name .
+                    \ ', Tag count=' . s:tlist_{fidx}_{ttype}_count
+        return
+    endif
+
+    " Get the tag search pattern and display it
+    echo s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Find_Nearest_Tag_Idx
+" Find the tag idx nearest to the supplied line number
+" Returns -1, if a tag couldn't be found for the specified line number
+function! s:Tlist_Find_Nearest_Tag_Idx(fidx, linenum)
+    let sort_type = s:tlist_{a:fidx}_sort_type
+
+    let left = 1
+    let right = s:tlist_{a:fidx}_tag_count
+
+    if sort_type == 'order'
+        " Tags sorted by order, use a binary search.
+        " The idea behind this function is taken from the ctags.vim script (by
+        " Alexey Marinichev) available at the Vim online website.
+
+        " If the current line is the less than the first tag, then no need to
+        " search
+        let first_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, 1)
+
+        if a:linenum < first_lnum
+            return -1
+        endif
+
+        while left < right
+            let middle = (right + left + 1) / 2
+            let middle_lnum = s:Tlist_Get_Tag_Linenum(a:fidx, middle)
+
+            if middle_lnum == a:linenum
+                let left = middle
+                break
+            endif
+
+            if middle_lnum > a:linenum
+                let right = middle - 1
+            else
+                let left = middle
+            endif
+        endwhile
+    else
+        " Tags sorted by name, use a linear search. (contributed by Dave
+        " Eggum).
+        " Look for a tag with a line number less than or equal to the supplied
+        " line number. If multiple tags are found, then use the tag with the
+        " line number closest to the supplied line number. IOW, use the tag
+        " with the highest line number.
+        let closest_lnum = 0
+        let final_left = 0
+        while left <= right
+            let lnum = s:Tlist_Get_Tag_Linenum(a:fidx, left)
+
+            if lnum < a:linenum && lnum > closest_lnum
+                let closest_lnum = lnum
+                let final_left = left
+            elseif lnum == a:linenum
+                let closest_lnum = lnum
+                let final_left = left
+                break
+            else
+                let left = left + 1
+            endif
+        endwhile
+        if closest_lnum == 0
+            return -1
+        endif
+        if left >= right
+            let left = final_left
+        endif
+    endif
+
+    return left
+endfunction
+
+" Tlist_Window_Highlight_Tag()
+" Highlight the current tag
+" cntx == 1, Called by the taglist plugin itself
+" cntx == 2, Forced by the user through the TlistHighlightTag command
+" center = 1, move the tag line to the center of the taglist window
+function! s:Tlist_Window_Highlight_Tag(filename, cur_lnum, cntx, center)
+    " Highlight the current tag only if the user configured the
+    " taglist plugin to do so or if the user explictly invoked the
+    " command to highlight the current tag.
+    if !g:Tlist_Auto_Highlight_Tag && a:cntx == 1
+        return
+    endif
+
+    if a:filename == ''
+        return
+    endif
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Error: Taglist window is not open')
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        return
+    endif
+
+    " If the file is currently not displayed in the taglist window, then retrn
+    if !s:tlist_{fidx}_visible
+        return
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return
+    endif
+
+    " Ignore all autocommands
+    let old_ei = &eventignore
+    set eventignore=all
+
+    " Save the original window number
+    let org_winnr = winnr()
+
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        exe winnum . 'wincmd w'
+    endif
+
+    " Clear previously selected name
+    match none
+
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, a:cur_lnum)
+    if tidx == -1
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        let lnum = line('.')
+
+        if lnum < s:tlist_{fidx}_start || lnum > s:tlist_{fidx}_end
+            " Move the cursor to the beginning of the file
+            exe s:tlist_{fidx}_start
+        endif
+
+        if foldclosed('.') != -1
+            .foldopen
+        endif
+
+        call winline()
+
+        if !in_taglist_window
+            exe org_winnr . 'wincmd w'
+        endif
+
+        " Restore the autocommands
+        let &eventignore = old_ei
+        return
+    endif
+
+    " Extract the tag type
+    let ttype = s:Tlist_Get_Tag_Type_By_Tag(fidx, tidx)
+
+    " Compute the line number
+    " Start of file + Start of tag type + offset
+    let lnum = s:tlist_{fidx}_start + s:tlist_{fidx}_{ttype}_offset +
+                \ s:tlist_{fidx}_{tidx}_ttype_idx
+
+    " Goto the line containing the tag
+    exe lnum
+
+    " Open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+
+    if a:center
+        " Move the tag line to the center of the taglist window
+        normal! z.
+    else
+        " Make sure the current tag line is visible in the taglist window.
+        " Calling the winline() function makes the line visible.  Don't know
+        " of a better way to achieve this.
+        call winline()
+    endif
+
+    " Highlight the tag name
+    call s:Tlist_Window_Highlight_Line()
+
+    " Go back to the original window
+    if !in_taglist_window
+        exe org_winnr . 'wincmd w'
+    endif
+
+    " Restore the autocommands
+    let &eventignore = old_ei
+    return
+endfunction
+
+" Tlist_Get_Tag_Prototype_By_Line
+" Get the prototype for the tag on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tag_Prototype_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tag_Prototype_By_Line <filename> ' .
+                                \ '<line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Expand the file to a fully qualified name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag text using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:Tlist_Get_Tag_Prototype(fidx, tidx)
+endfunction
+
+" Tlist_Get_Tagname_By_Line
+" Get the tag name on or before the specified line number in the
+" current buffer
+function! Tlist_Get_Tagname_By_Line(...)
+    if a:0 == 0
+        " Arguments are not supplied. Use the current buffer name
+        " and line number
+        let filename = bufname('%')
+        let linenr = line('.')
+    elseif a:0 == 2
+        " Filename and line number are specified
+        let filename = a:1
+        let linenr = a:2
+        if linenr !~ '\d\+'
+            " Invalid line number
+            return ""
+        endif
+    else
+        " Sufficient arguments are not supplied
+        let msg =  'Usage: Tlist_Get_Tagname_By_Line <filename> <line_number>'
+        call s:Tlist_Warning_Msg(msg)
+        return ""
+    endif
+
+    " Make sure the current file has a name
+    let filename = fnamemodify(filename, ':p')
+    if filename == ''
+        return ""
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1
+        return ""
+    endif
+
+    " If there are no tags for this file, then no need to proceed further
+    if s:tlist_{fidx}_tag_count == 0
+        return ""
+    endif
+
+    " Get the tag name using the line number
+    let tidx = s:Tlist_Find_Nearest_Tag_Idx(fidx, linenr)
+    if tidx == -1
+        return ""
+    endif
+
+    return s:tlist_{fidx}_{tidx}_tag_name
+endfunction
+
+" Tlist_Window_Move_To_File
+" Move the cursor to the beginning of the current file or the next file
+" or the previous file in the taglist window
+" dir == -1, move to start of current or previous function
+" dir == 1, move to start of next function
+function! s:Tlist_Window_Move_To_File(dir)
+    if foldlevel('.') == 0
+        " Cursor is on a non-folded line (it is not in any of the files)
+        " Move it to a folded line
+        if a:dir == -1
+            normal! zk
+        else
+            " While moving down to the start of the next fold,
+            " no need to do go to the start of the next file.
+            normal! zj
+            return
+        endif
+    endif
+
+    let fidx = s:Tlist_Window_Get_File_Index_By_Linenum(line('.'))
+    if fidx == -1
+        return
+    endif
+
+    let cur_lnum = line('.')
+
+    if a:dir == -1
+        if cur_lnum > s:tlist_{fidx}_start
+            " Move to the beginning of the current file
+            exe s:tlist_{fidx}_start
+            return
+        endif
+
+        if fidx != 0
+            " Move to the beginning of the previous file
+            let fidx = fidx - 1
+        else
+            " Cursor is at the first file, wrap around to the last file
+            let fidx = s:tlist_file_count - 1
+        endif
+
+        exe s:tlist_{fidx}_start
+        return
+    else
+        " Move to the beginning of the next file
+        let fidx = fidx + 1
+
+        if fidx >= s:tlist_file_count
+            " Cursor is at the last file, wrap around to the first file
+            let fidx = 0
+        endif
+
+        if s:tlist_{fidx}_start != 0
+            exe s:tlist_{fidx}_start
+        endif
+        return
+    endif
+endfunction
+
+" Tlist_Session_Load
+" Load a taglist session (information about all the displayed files
+" and the tags) from the specified file
+function! s:Tlist_Session_Load(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionLoad <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if !filereadable(sessionfile)
+        let msg = 'Taglist: Error - Unable to open file ' . sessionfile
+        call s:Tlist_Warning_Msg(msg)
+        return
+    endif
+
+    " Mark the current window as the file window
+    call s:Tlist_Window_Mark_File_Window()
+
+    " Source the session file
+    exe 'source ' . sessionfile
+
+    let new_file_count = g:tlist_file_count
+    unlet! g:tlist_file_count
+
+    let i = 0
+    while i < new_file_count
+        let ftype = g:tlist_{i}_filetype
+        unlet! g:tlist_{i}_filetype
+
+        if !exists('s:tlist_' . ftype . '_count')
+            if s:Tlist_FileType_Init(ftype) == 0
+                let i = i + 1
+                continue
+            endif
+        endif
+
+        let fname = g:tlist_{i}_filename
+        unlet! g:tlist_{i}_filename
+
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            let s:tlist_{fidx}_visible = 0
+            let i = i + 1
+            continue
+        else
+            " As we are loading the tags from the session file, if this
+            " file was previously deleted by the user, now we need to
+            " add it back. So remove the file from the deleted list.
+            call s:Tlist_Update_Remove_List(fname, 0)
+        endif
+
+        let fidx = s:Tlist_Init_File(fname, ftype)
+
+        let s:tlist_{fidx}_filename = fname
+
+        let s:tlist_{fidx}_sort_type = g:tlist_{i}_sort_type
+        unlet! g:tlist_{i}_sort_type
+
+        let s:tlist_{fidx}_filetype = ftype
+        let s:tlist_{fidx}_mtime = getftime(fname)
+
+        let s:tlist_{fidx}_start = 0
+        let s:tlist_{fidx}_end = 0
+
+        let s:tlist_{fidx}_valid = 1
+
+        let s:tlist_{fidx}_tag_count = g:tlist_{i}_tag_count
+        unlet! g:tlist_{i}_tag_count
+
+        let j = 1
+        while j <= s:tlist_{fidx}_tag_count
+            let s:tlist_{fidx}_{j}_tag = g:tlist_{i}_{j}_tag
+            let s:tlist_{fidx}_{j}_tag_name = g:tlist_{i}_{j}_tag_name
+            let s:tlist_{fidx}_{j}_ttype_idx = g:tlist_{i}_{j}_ttype_idx
+            unlet! g:tlist_{i}_{j}_tag
+            unlet! g:tlist_{i}_{j}_tag_name
+            unlet! g:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+
+            if exists('g:tlist_' . i . '_' . ttype)
+                let s:tlist_{fidx}_{ttype} = g:tlist_{i}_{ttype}
+                unlet! g:tlist_{i}_{ttype}
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = g:tlist_{i}_{ttype}_count
+                unlet! g:tlist_{i}_{ttype}_count
+
+                let k = 1
+                while k <= s:tlist_{fidx}_{ttype}_count
+                    let s:tlist_{fidx}_{ttype}_{k} = g:tlist_{i}_{ttype}_{k}
+                    unlet! g:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            else
+                let s:tlist_{fidx}_{ttype} = ''
+                let s:tlist_{fidx}_{ttype}_offset = 0
+                let s:tlist_{fidx}_{ttype}_count = 0
+            endif
+
+            let j = j + 1
+        endwhile
+
+        let i = i + 1
+    endwhile
+
+    " If the taglist window is open, then update it
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum != -1
+        let save_winnr = winnr()
+
+        " Goto the taglist window
+        call s:Tlist_Window_Goto_Window()
+
+        " Refresh the taglist window
+        call s:Tlist_Window_Refresh()
+
+        " Go back to the original window
+        if save_winnr != winnr()
+            call s:Tlist_Exe_Cmd_No_Acmds('wincmd p')
+        endif
+    endif
+endfunction
+
+" Tlist_Session_Save
+" Save a taglist session (information about all the displayed files
+" and the tags) into the specified file
+function! s:Tlist_Session_Save(...)
+    if a:0 == 0 || a:1 == ''
+        call s:Tlist_Warning_Msg('Usage: TlistSessionSave <filename>')
+        return
+    endif
+
+    let sessionfile = a:1
+
+    if s:tlist_file_count == 0
+        " There is nothing to save
+        call s:Tlist_Warning_Msg('Warning: Taglist is empty. Nothing to save.')
+        return
+    endif
+
+    if filereadable(sessionfile)
+        let ans = input('Do you want to overwrite ' . sessionfile . ' (Y/N)?')
+        if ans !=? 'y'
+            return
+        endif
+
+        echo "\n"
+    endif
+
+    let old_verbose = &verbose
+    set verbose&vim
+
+    exe 'redir! > ' . sessionfile
+
+    silent! echo '" Taglist session file. This file is auto-generated.'
+    silent! echo '" File information'
+    silent! echo 'let tlist_file_count = ' . s:tlist_file_count
+
+    let i = 0
+
+    while i < s:tlist_file_count
+        " Store information about the file
+        silent! echo 'let tlist_' . i . "_filename = '" .
+                                            \ s:tlist_{i}_filename . "'"
+        silent! echo 'let tlist_' . i . '_sort_type = "' .
+                                                \ s:tlist_{i}_sort_type . '"'
+        silent! echo 'let tlist_' . i . '_filetype = "' .
+                                            \ s:tlist_{i}_filetype . '"'
+        silent! echo 'let tlist_' . i . '_tag_count = ' .
+                                                        \ s:tlist_{i}_tag_count
+        " Store information about all the tags
+        let j = 1
+        while j <= s:tlist_{i}_tag_count
+            let txt = escape(s:tlist_{i}_{j}_tag, '"\\')
+            silent! echo 'let tlist_' . i . '_' . j . '_tag = "' . txt . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_tag_name = "' .
+                        \ s:tlist_{i}_{j}_tag_name . '"'
+            silent! echo 'let tlist_' . i . '_' . j . '_ttype_idx' . ' = ' .
+                        \ s:tlist_{i}_{j}_ttype_idx
+            let j = j + 1
+        endwhile
+
+        " Store information about all the tags grouped by their type
+        let ftype = s:tlist_{i}_filetype
+        let j = 1
+        while j <= s:tlist_{ftype}_count
+            let ttype = s:tlist_{ftype}_{j}_name
+            if s:tlist_{i}_{ttype}_count != 0
+                let txt = substitute(s:tlist_{i}_{ttype}, "\n", "\\\\n", 'g')
+                silent! echo 'let tlist_' . i . '_' . ttype . ' = "' .
+                                                \ txt . '"'
+                silent! echo 'let tlist_' . i . '_' . ttype . '_count = ' .
+                                                     \ s:tlist_{i}_{ttype}_count
+                let k = 1
+                while k <= s:tlist_{i}_{ttype}_count
+                    silent! echo 'let tlist_' . i . '_' . ttype . '_' . k .
+                                \ ' = ' . s:tlist_{i}_{ttype}_{k}
+                    let k = k + 1
+                endwhile
+            endif
+            let j = j + 1
+        endwhile
+
+        silent! echo
+
+        let i = i + 1
+    endwhile
+
+    redir END
+
+    let &verbose = old_verbose
+endfunction
+
+" Tlist_Buffer_Removed
+" A buffer is removed from the Vim buffer list. Remove the tags defined
+" for that file
+function! s:Tlist_Buffer_Removed(filename)
+    call s:Tlist_Log_Msg('Tlist_Buffer_Removed (' . a:filename .  ')')
+
+    " Make sure a valid filename is supplied
+    if a:filename == ''
+        return
+    endif
+
+    " Get tag list index of the specified file
+    let fidx = s:Tlist_Get_File_Index(a:filename)
+    if fidx == -1
+        " File not present in the taglist
+        return
+    endif
+
+    " Remove the file from the list
+    call s:Tlist_Remove_File(fidx, 0)
+endfunction
+
+" When a buffer is deleted, remove the file from the taglist
+autocmd BufDelete * silent call s:Tlist_Buffer_Removed(expand('<afile>:p'))
+
+" Tlist_Window_Open_File_Fold
+" Open the fold for the specified file and close the fold for all the
+" other files
+function! s:Tlist_Window_Open_File_Fold(acmd_file)
+    call s:Tlist_Log_Msg('Tlist_Window_Open_File_Fold (' . a:acmd_file . ')')
+
+    " Make sure the taglist window is present
+    let winnum = bufwinnr(g:TagList_title)
+    if winnum == -1
+        call s:Tlist_Warning_Msg('Taglist: Error - Taglist window is not open')
+        return
+    endif
+
+    " Save the original window number
+    let org_winnr = winnr()
+    if org_winnr == winnum
+        let in_taglist_window = 1
+    else
+        let in_taglist_window = 0
+    endif
+
+    if in_taglist_window
+        " When entering the taglist window, no need to update the folds
+        return
+    endif
+
+    " Go to the taglist window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(winnum . 'wincmd w')
+    endif
+
+    " Close all the folds
+    silent! %foldclose
+
+    " Get tag list index of the specified file
+    let fname = fnamemodify(a:acmd_file, ":p")
+    if filereadable(fname)
+        let fidx = s:Tlist_Get_File_Index(fname)
+        if fidx != -1
+            " Open the fold for the file
+            exe "silent! " . s:tlist_{fidx}_start . "," .
+                        \ s:tlist_{fidx}_end . "foldopen"
+        endif
+    endif
+
+    " Go back to the original window
+    if !in_taglist_window
+        call s:Tlist_Exe_Cmd_No_Acmds(org_winnr . 'wincmd w')
+    endif
+endfunction
+
+" Tlist_Window_Check_Auto_Open
+" Open the taglist window automatically on Vim startup.
+" Open the window only when files present in any of the Vim windows support
+" tags.
+function! s:Tlist_Window_Check_Auto_Open()
+    let open_window = 0
+
+    let i = 1
+    let buf_num = winbufnr(i)
+    while buf_num != -1
+        let filename = fnamemodify(bufname(buf_num), ':p')
+        if !s:Tlist_Skip_File(filename, getbufvar(buf_num, '&filetype'))
+            let open_window = 1
+            break
+        endif
+        let i = i + 1
+        let buf_num = winbufnr(i)
+    endwhile
+
+    if open_window
+        call s:Tlist_Window_Toggle()
+    endif
+endfunction
+
+function! s:Tlist_Menu_Add_Base_Menu()
+    call s:Tlist_Log_Msg('Adding the base menu')
+
+    " Add the menu
+    anoremenu <silent> T&ags.Refresh\ menu :call <SID>Tlist_Menu_Refresh()<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Name
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+    anoremenu <silent> T&ags.Sort\ menu\ by.Order
+                    \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+    anoremenu T&ags.-SEP1-           :
+
+    if &mousemodel =~ 'popup'
+        anoremenu <silent> PopUp.T&ags.Refresh\ menu
+                    \ :call <SID>Tlist_Menu_Refresh()<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Name
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'name')<CR>
+        anoremenu <silent> PopUp.T&ags.Sort\ menu\ by.Order
+                  \ :call <SID>Tlist_Change_Sort('menu', 'set', 'order')<CR>
+        anoremenu PopUp.T&ags.-SEP1-           :
+    endif
+endfunction
+
+let s:menu_char_prefix =
+            \ '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
+
+" Tlist_Menu_Get_Tag_Type_Cmd
+" Get the menu command for the specified tag type
+" fidx - File type index
+" ftype - File Type
+" add_ttype_name - To add or not to add the tag type name to the menu entries
+" ttype_idx - Tag type index
+function! s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, ttype_idx)
+    " Curly brace variable name optimization
+    let ftype_ttype_idx = a:ftype . '_' . a:ttype_idx
+
+    let ttype = s:tlist_{ftype_ttype_idx}_name
+    if a:add_ttype_name
+        " If the tag type name contains space characters, escape it. This
+        " will be used to create the menu entries.
+        let ttype_fullname = escape(s:tlist_{ftype_ttype_idx}_fullname, ' ')
+    endif
+
+    " Curly brace variable name optimization
+    let fidx_ttype = a:fidx . '_' . ttype
+
+    " Number of tag entries for this tag type
+    let tcnt = s:tlist_{fidx_ttype}_count
+    if tcnt == 0 " No entries for this tag type
+        return ''
+    endif
+
+    let mcmd = ''
+
+    " Create the menu items for the tags.
+    " Depending on the number of tags of this type, split the menu into
+    " multiple sub-menus, if needed.
+    if tcnt > g:Tlist_Max_Submenu_Items
+        let j = 1
+        while j <= tcnt
+            let final_index = j + g:Tlist_Max_Submenu_Items - 1
+            if final_index > tcnt
+                let final_index = tcnt
+            endif
+
+            " Extract the first and last tag name and form the
+            " sub-menu name
+            let tidx = s:tlist_{fidx_ttype}_{j}
+            let first_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let tidx = s:tlist_{fidx_ttype}_{final_index}
+            let last_tag = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            " Truncate the names, if they are greater than the
+            " max length
+            let first_tag = strpart(first_tag, 0, g:Tlist_Max_Tag_Length)
+            let last_tag = strpart(last_tag, 0, g:Tlist_Max_Tag_Length)
+
+            " Form the menu command prefix
+            let m_prefix = 'anoremenu <silent> T\&ags.'
+            if a:add_ttype_name
+                let m_prefix = m_prefix . ttype_fullname . '.'
+            endif
+            let m_prefix = m_prefix . first_tag . '\.\.\.' . last_tag . '.'
+
+            " Character prefix used to number the menu items (hotkey)
+            let m_prefix_idx = 0
+
+            while j <= final_index
+                let tidx = s:tlist_{fidx_ttype}_{j}
+
+                let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+                let mcmd = mcmd . m_prefix . '\&' .
+                            \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                            \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' .
+                            \ tidx . ')<CR>|'
+
+                let m_prefix_idx = m_prefix_idx + 1
+                let j = j + 1
+            endwhile
+        endwhile
+    else
+        " Character prefix used to number the menu items (hotkey)
+        let m_prefix_idx = 0
+
+        let m_prefix = 'anoremenu <silent> T\&ags.'
+        if a:add_ttype_name
+            let m_prefix = m_prefix . ttype_fullname . '.'
+        endif
+        let j = 1
+        while j <= tcnt
+            let tidx = s:tlist_{fidx_ttype}_{j}
+
+            let tname = s:tlist_{a:fidx}_{tidx}_tag_name
+
+            let mcmd = mcmd . m_prefix . '\&' .
+                        \ s:menu_char_prefix[m_prefix_idx] . '\.' .
+                        \ tname . ' :call <SID>Tlist_Menu_Jump_To_Tag(' . tidx
+                        \ . ')<CR>|'
+
+            let m_prefix_idx = m_prefix_idx + 1
+            let j = j + 1
+        endwhile
+    endif
+
+    return mcmd
+endfunction
+
+" Update the taglist menu with the tags for the specified file
+function! s:Tlist_Menu_File_Refresh(fidx)
+    call s:Tlist_Log_Msg('Refreshing the tag menu for ' . s:tlist_{a:fidx}_filename)
+    " The 'B' flag is needed in the 'cpoptions' option
+    let old_cpoptions = &cpoptions
+    set cpoptions&vim
+
+    exe s:tlist_{a:fidx}_menu_cmd
+
+    " Update the popup menu (if enabled)
+    if &mousemodel =~ 'popup'
+        let cmd = substitute(s:tlist_{a:fidx}_menu_cmd, ' T\\&ags\.',
+                                        \ ' PopUp.T\\\&ags.', "g")
+        exe cmd
+    endif
+
+    " The taglist menu is not empty now
+    let s:tlist_menu_empty = 0
+
+    " Restore the 'cpoptions' settings
+    let &cpoptions = old_cpoptions
+endfunction
+
+" Tlist_Menu_Update_File
+" Add the taglist menu
+function! s:Tlist_Menu_Update_File(clear_menu)
+    if !has('gui_running')
+        " Not running in GUI mode
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Updating the tag menu, clear_menu = ' . a:clear_menu)
+
+    " Remove the tags menu
+    if a:clear_menu
+        call s:Tlist_Menu_Remove_File()
+
+    endif
+
+    let fname = escape(fnamemodify(bufname('%'), ':t'), '.')
+    if fname != ''
+        exe 'anoremenu T&ags.' .  fname . ' <Nop>'
+        anoremenu T&ags.-SEP2-           :
+    endif
+
+    " Skip buffers with 'buftype' set to nofile, nowrite, quickfix or help
+    if &buftype != ''
+        return
+    endif
+
+    let filename = fnamemodify(bufname('%'), ':p')
+    let ftype = &filetype
+
+    " If the file doesn't support tag listing, skip it
+    if s:Tlist_Skip_File(filename, ftype)
+        return
+    endif
+
+    let fidx = s:Tlist_Get_File_Index(filename)
+    if fidx == -1 || !s:tlist_{fidx}_valid
+        " Check whether this file is removed based on user request
+        " If it is, then don't display the tags for this file
+        if s:Tlist_User_Removed_File(filename)
+            return
+        endif
+
+        " Process the tags for the file
+        let fidx = s:Tlist_Process_File(filename, ftype)
+        if fidx == -1
+            return
+        endif
+    endif
+
+    if !s:tlist_{fidx}_tag_count
+        return
+    endif
+
+    if s:tlist_{fidx}_menu_cmd != ''
+        " Update the menu with the cached command
+        call s:Tlist_Menu_File_Refresh(fidx)
+
+        return
+    endif
+
+    " We are going to add entries to the tags menu, so the menu won't be
+    " empty
+    let s:tlist_menu_empty = 0
+
+    let cmd = ''
+
+    " Determine whether the tag type name needs to be added to the menu
+    " If more than one tag type is present in the taglisting for a file,
+    " then the tag type name needs to be present
+    let add_ttype_name = -1
+    let i = 1
+    while i <= s:tlist_{ftype}_count && add_ttype_name < 1
+        let ttype = s:tlist_{ftype}_{i}_name
+        if s:tlist_{fidx}_{ttype}_count
+            let add_ttype_name = add_ttype_name + 1
+        endif
+        let i = i + 1
+    endwhile
+
+    " Process the tags by the tag type and get the menu command
+    let i = 1
+    while i <= s:tlist_{ftype}_count
+        let mcmd = s:Tlist_Menu_Get_Tag_Type_Cmd(fidx, ftype, add_ttype_name, i)
+        if mcmd != ''
+            let cmd = cmd . mcmd
+        endif
+
+        let i = i + 1
+    endwhile
+
+    " Cache the menu command for reuse
+    let s:tlist_{fidx}_menu_cmd = cmd
+
+    " Update the menu
+    call s:Tlist_Menu_File_Refresh(fidx)
+endfunction
+
+" Tlist_Menu_Remove_File
+" Remove the tags displayed in the tags menu
+function! s:Tlist_Menu_Remove_File()
+    if !has('gui_running') || s:tlist_menu_empty
+        return
+    endif
+
+    call s:Tlist_Log_Msg('Removing the tags menu for a file')
+
+    " Cleanup the Tags menu
+    silent! unmenu T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu PopUp.T&ags
+    endif
+
+    " Add a dummy menu item to retain teared off menu
+    noremenu T&ags.Dummy l
+
+    silent! unmenu! T&ags
+    if &mousemodel =~ 'popup'
+        silent! unmenu! PopUp.T&ags
+    endif
+
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Remove the dummy menu item
+    unmenu T&ags.Dummy
+
+    let s:tlist_menu_empty = 1
+endfunction
+
+" Tlist_Menu_Refresh
+" Refresh the taglist menu
+function! s:Tlist_Menu_Refresh()
+    call s:Tlist_Log_Msg('Refreshing the tags menu')
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx != -1
+        " Invalidate the cached menu command
+        let s:tlist_{fidx}_menu_cmd = ''
+    endif
+
+    " Update the taglist, menu and window
+    call s:Tlist_Update_Current_File()
+endfunction
+
+" Tlist_Menu_Jump_To_Tag
+" Jump to the selected tag
+function! s:Tlist_Menu_Jump_To_Tag(tidx)
+    let fidx = s:Tlist_Get_File_Index(fnamemodify(bufname('%'), ':p'))
+    if fidx == -1
+        return
+    endif
+
+    let tagpat = s:Tlist_Get_Tag_SearchPat(fidx, a:tidx)
+    if tagpat == ''
+        return
+    endif
+
+    " Add the current cursor position to the jump list, so that user can
+    " jump back using the ' and ` marks.
+    mark '
+
+    silent call search(tagpat, 'w')
+
+    " Bring the line to the middle of the window
+    normal! z.
+
+    " If the line is inside a fold, open the fold
+    if foldclosed('.') != -1
+        .foldopen
+    endif
+endfunction
+
+" Tlist_Menu_Init
+" Initialize the taglist menu
+function! s:Tlist_Menu_Init()
+    call s:Tlist_Menu_Add_Base_Menu()
+
+    " Automatically add the tags defined in the current file to the menu
+    augroup TagListMenuCmds
+        autocmd!
+
+        if !g:Tlist_Process_File_Always
+            autocmd BufEnter * call s:Tlist_Refresh()
+        endif
+        autocmd BufLeave * call s:Tlist_Menu_Remove_File()
+    augroup end
+
+    call s:Tlist_Menu_Update_File(0)
+endfunction
+
+" Tlist_Vim_Session_Load
+" Initialize the taglist window/buffer, which is created when loading
+" a Vim session file.
+function! s:Tlist_Vim_Session_Load()
+    call s:Tlist_Log_Msg('Tlist_Vim_Session_Load')
+
+    " Initialize the taglist window
+    call s:Tlist_Window_Init()
+
+    " Refresh the taglist window
+    call s:Tlist_Window_Refresh()
+endfunction
+
+" Tlist_Set_App
+" Set the name of the external plugin/application to which taglist
+" belongs.
+" Taglist plugin is part of another plugin like cream or winmanager.
+function! Tlist_Set_App(name)
+    if a:name == ""
+        return
+    endif
+
+    let s:tlist_app_name = a:name
+endfunction
+
+" Winmanager integration
+
+" Initialization required for integration with winmanager
+function! TagList_Start()
+    " If current buffer is not taglist buffer, then don't proceed
+    if bufname('%') != '__Tag_List__'
+        return
+    endif
+
+    call Tlist_Set_App('winmanager')
+
+    " Get the current filename from the winmanager plugin
+    let bufnum = WinManagerGetLastEditedFile()
+    if bufnum != -1
+        let filename = fnamemodify(bufname(bufnum), ':p')
+        let ftype = getbufvar(bufnum, '&filetype')
+    endif
+
+    " Initialize the taglist window, if it is not already initialized
+    if !exists('s:tlist_window_initialized') || !s:tlist_window_initialized
+        call s:Tlist_Window_Init()
+        call s:Tlist_Window_Refresh()
+        let s:tlist_window_initialized = 1
+    endif
+
+    " Update the taglist window
+    if bufnum != -1
+        if !s:Tlist_Skip_File(filename, ftype) && g:Tlist_Auto_Update
+            call s:Tlist_Window_Refresh_File(filename, ftype)
+        endif
+    endif
+endfunction
+
+function! TagList_IsValid()
+    return 0
+endfunction
+
+function! TagList_WrapUp()
+    return 0
+endfunction
+
+" restore 'cpo'
+let &cpo = s:cpo_save
+unlet s:cpo_save
+
diff -urN vim71/runtime/syntax/ada.vim vim71_ada/runtime/syntax/ada.vim
--- vim71/runtime/syntax/ada.vim	2007-05-05 20:22:26.000000000 +0200
+++ vim71_ada/runtime/syntax/ada.vim	2008-01-16 16:37:03.000000000 +0100
@@ -1,17 +1,17 @@
 "----------------------------------------------------------------------------
 "  Description: Vim Ada syntax file
 "     Language: Ada (2005)
-"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
+"	   $Id: vim-7.1-ada.patch,v 1.1 2008/02/11 16:41:46 karsten Exp $
 "    Copyright: Copyright (C) 2006 Martin Krischik
 "   Maintainer: Martin Krischik
 "		David A. Wheeler <dwheeler@dwheeler.com>
 "		Simon Bradley <simon.bradley@pitechnology.com>
 " Contributors: Preben Randhol.
-"      $Author: karsten $
-"	 $Date: 2008/02/11 16:41:46 $
-"      Version: 4.2
-"    $Revision: 1.1 $
-"     $HeadURL: https://svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/syntax/ada.vim $
+"      $Author: karsten $
+"	 $Date: 2008/02/11 16:41:46 $
+"      Version: 4.5
+"    $Revision: 1.1 $
+"     $HeadURL: https://gnuada.svn.sourceforge.net/svnroot/gnuada/trunk/tools/vim/syntax/ada.vim $
 "		http://www.dwheeler.com/vim
 "      History: 24.05.2006 MK Unified Headers
 "		26.05.2006 MK ' should not be in iskeyword.
@@ -98,7 +98,8 @@
 "
 if exists("g:ada_rainbow_color")
     syntax match	adaSpecial	 "[:;.,]"
-    runtime plugin/Rainbow_Parenthsis.vim
+    call rainbow_parenthsis#LoadRound ()
+    call rainbow_parenthsis#Activate ()
 else
     syntax match	adaSpecial	 "[:;().,]"
 endif
@@ -159,7 +160,7 @@
 " Section: end {{{1
 " Unless special ("end loop", "end if", etc.), "end" marks the end of a
 " begin, package, task etc. Assiging it to adaEnd.
-syntax match    adaEnd	"\<end\>"
+syntax match    adaEnd	/\<end\>/
 
 syntax keyword  adaPreproc		 pragma
 
diff -urN vim71/runtime/syntax/bush.vim vim71_ada/runtime/syntax/bush.vim
--- vim71/runtime/syntax/bush.vim	1970-01-01 01:00:00.000000000 +0100
+++ vim71_ada/runtime/syntax/bush.vim	2008-01-16 16:37:03.000000000 +0100
@@ -0,0 +1,309 @@
+" Vim syntax file
+" Language:	BUSH / AdaScript
+" Maintainer:	Ken O. Burtch <ken@pegasoft.ca>
+" URL: http://www.pegasoft.ca/bush
+" Last Change:	2004-06-29
+
+" Former Maintainer:	Simon Bradley <simon.bradley@pitechnology.com>
+"			(was <sib93@aber.ac.uk>)
+" Other contributors: Preben Randhol.
+" The formal spec of Ada95 (ARM) is the "Ada95 Reference Manual".
+" For more Ada95 info, see http://www.gnuada.org and http://www.adapower.com.
+
+" This vim syntax file works on vim 5.6, 5.7, 5.8 and 6.x.
+" It implements Bram Moolenaar's April 25, 2001 recommendations to make
+" the syntax file maximally portable across different versions of vim.
+" If vim 6.0+ is available,
+" this syntax file takes advantage of the vim 6.0 advanced pattern-matching
+" functions to avoid highlighting uninteresting leading spaces in
+" some expressions containing "with" and "use".
+
+" For version 5.x: Clear all syntax items
+" For version 6.x: Quit when a syntax file was already loaded
+if version < 600
+ syntax clear
+elseif exists("b:current_syntax")
+ finish
+endif
+
+" Ada is entirely case-insensitive.
+syn case ignore
+
+" We don't need to look backwards to highlight correctly;
+" this speeds things up greatly.
+syn sync minlines=1 maxlines=1
+
+" Highlighting commands.  There are 69 reserved words in total in Ada95.
+" Some keywords are used in more than one way. For example:
+" 1. "end" is a general keyword, but "end if" ends a Conditional.
+" 2. "then" is a conditional, but "and then" is an operator.
+
+
+" Standard Exceptions (including I/O).
+" We'll highlight the standard exceptions, similar to vim's Python mode.
+" It's possible to redefine the standard exceptions as something else,
+" but doing so is very bad practice, so simply highlighting them makes sense.
+syn keyword adaException Constraint_Error Program_Error Storage_Error
+syn keyword adaException Tasking_Error
+syn keyword adaException Status_Error Mode_Error Name_Error Use_Error
+syn keyword adaException Device_Error End_Error Data_Error Layout_Error
+syn keyword adaException Length_Error Pattern_Error Index_Error
+syn keyword adaException Translation_Error
+syn keyword adaException Time_Error Argument_Error
+syn keyword adaException Tag_Error
+syn keyword adaException Picture_Error
+" Interfaces
+syn keyword adaException Terminator_Error Conversion_Error
+syn keyword adaException Pointer_Error Dereference_Error Update_Error
+" This isn't in the Ada spec, but a GNAT extension.
+syn keyword adaException Assert_Failure
+" We don't list ALL exceptions defined in particular compilers (e.g., GNAT),
+" because it's quite reasonable to define those phrases as non-exceptions.
+
+
+" We don't normally highlight types in package Standard
+" (Integer, Character, Float, etc.).  I don't think it looks good
+" with the other type keywords, and many Ada programs define
+" so many of their own types that it looks inconsistent.
+" However, if you want this highlighting, turn on "ada_standard_types".
+" For package Standard's definition, see ARM section A.1.
+
+if exists("ada_standard_types")
+  syn keyword adaBuiltinType	Boolean Integer Natural Positive Float
+  syn keyword adaBuiltinType	Character Wide_Character
+  syn keyword adaBuiltinType	String Wide_String
+  syn keyword adaBuiltinType	Duration
+  " These aren't listed in ARM section A.1's code, but they're noted as
+  " options in ARM sections 3.5.4 and 3.5.7:
+  syn keyword adaBuiltinType	Short_Integer Short_Short_Integer
+  syn keyword adaBuiltinType	Long_Integer Long_Long_Integer
+  syn keyword adaBuiltinType	Short_Float Short_Short_Float
+  syn keyword adaBuiltinType	Long_Float Long_Long_Float
+  " BUSH-specific types
+  syn keyword adaBuiltinType    command
+  syn keyword adaBuiltinType    socket_type
+  syn keyword adaBuiltinType    unbounded_string
+  syn keyword adaBuiltinType    universal_typeless
+  syn keyword adaBuiltinType    universal_string
+  syn keyword adaBuiltinType    universal_numeric
+endif
+
+" There are MANY other predefined types; they've not been added, because
+" determining when they're a type requires context in general.
+" One potential addition would be Unbounded_String.
+
+
+syn keyword adaLabel		others
+
+syn keyword adaOperator		abs mod not rem xor
+syn match adaOperator		"\<and\>"
+syn match adaOperator		"\<and\s\+then\>"
+syn match adaOperator		"\<or\>"
+syn match adaOperator		"\<or\s\+else\>"
+syn match adaOperator		"[-+*/<>&]"
+syn keyword adaOperator		**
+syn match adaOperator		"[/<>]="
+syn keyword adaOperator		=>
+syn match adaOperator		"\.\."
+syn match adaOperator		"="
+
+" We won't map "adaAssignment" by default, but we need to map ":=" to
+" something or the "=" inside it will be mislabelled as an operator.
+" Note that in Ada, assignment (:=) is not considered an operator.
+syn match adaAssignment		":="
+
+" Handle the box, <>, specially:
+syn keyword adaSpecial	<>
+
+" Numbers, including floating point, exponents, and alternate bases.
+syn match   adaNumber		"\<\d[0-9_]*\(\.\d[0-9_]*\)\=\([Ee][+-]\=\d[0-9_]*\)\=\>"
+syn match   adaNumber		"\<\d\d\=#\x[0-9A-Fa-f_]*\(\.\x[0-9A-Fa-f_]*\)\=#\([Ee][+-]\=\d[0-9_]*\)\="
+
+" Identify leading numeric signs. In "A-5" the "-" is an operator,
+" but in "A:=-5" the "-" is a sign. This handles "A3+-5" (etc.) correctly.
+" This assumes that if you put a don't put a space after +/- when it's used
+" as an operator, you won't put a space before it either -- which is true
+" in code I've seen.
+syn match adaSign "[[:space:]<>=(,|:;&*/+-][+-]\d"lc=1,hs=s+1,he=e-1,me=e-1
+
+" Labels for the goto statement.
+syn region  adaLabel		start="<<"  end=">>"
+
+" Boolean Constants.
+syn keyword adaBoolean	true false
+
+" Warn people who try to use C/C++ notation erroneously:
+syn match adaError "//"
+syn match adaError "/\*"
+syn match adaError "=="
+
+
+if exists("ada_space_errors")
+  if !exists("ada_no_trail_space_error")
+    syn match   adaSpaceError     excludenl "\s\+$"
+  endif
+  if !exists("ada_no_tab_space_error")
+    syn match   adaSpaceError     " \+\t"me=e-1
+  endif
+endif
+
+" Unless special ("end loop", "end if", etc.), "end" marks the end of a
+" begin, package, task etc. Assiging it to adaEnd.
+syn match adaEnd		"\<end\>"
+
+syn keyword adaPreproc		pragma
+
+syn keyword adaRepeat		exit for loop reverse while
+syn match adaRepeat		"\<end\s\+loop\>"
+
+syn keyword adaStatement	accept delay goto raise requeue return
+syn keyword adaStatement	terminate
+" BUSH-specific statements
+syn keyword adaStatement	cd
+syn keyword adaStatement	clear
+syn keyword adaStatement	env
+syn keyword adaStatement	inkey
+syn keyword adaStatement	jobs
+syn keyword adaStatement	logout
+syn keyword adaStatement	pwd
+syn keyword adaStatement	step
+syn keyword adaStatement	trace
+syn keyword adaStatement	typeset
+syn keyword adaStatement	unset
+syn keyword adaStatement	wait
+syn keyword adaStatement	history
+syn keyword adaStatement	"?"
+syn match adaStatement	"\<abort\>"
+
+" Handle Ada's record keywords.
+" 'record' usually starts a structure, but "with null record;" does not,
+" and 'end record;' ends a structure.  The ordering here is critical -
+" 'record;' matches a "with null record", so make it a keyword (this can
+" match when the 'with' or 'null' is on a previous line).
+" We see the "end" in "end record" before the word record, so we match that
+" pattern as adaStructure (and it won't match the "record;" pattern).
+syn match adaStructure	"\<record\>"
+syn match adaStructure	"\<end\s\+record\>"
+syn match adaKeyword	"\<record;"me=e-1
+
+syn keyword adaStorageClass	abstract access aliased array at constant delta
+syn keyword adaStorageClass	digits limited of private range tagged
+syn keyword adaTypedef		subtype type
+
+" Conditionals. "abort" after "then" is a conditional of its own.
+syn match adaConditional	"\<then\>"
+syn match adaConditional	"\<then\s\+abort\>"
+syn match adaConditional	"\<else\>"
+syn match adaConditional	"\<end\s\+if\>"
+syn match adaConditional	"\<end\s\+case\>"
+syn match adaConditional	"\<end\s\+select\>"
+syn keyword adaConditional	if case select
+syn keyword adaConditional	elsif when
+
+syn keyword adaKeyword		all do exception in is new null out
+syn keyword adaKeyword		separate until
+
+" These keywords begin various constructs, and you _might_ want to
+" highlight them differently.
+syn keyword adaBegin		begin body declare entry function generic
+syn keyword adaBegin		package procedure protected renames task
+
+
+if exists("ada_withuse_ordinary")
+" Don't be fancy. Display "with" and "use" as ordinary keywords in all cases.
+ syn keyword adaKeyword		with use
+else
+ " Highlight "with" and "use" clauses like C's "#include" when they're used
+ " to reference other compilation units; otherwise they're ordinary keywords.
+ " If we have vim 6.0 or later, we'll use its advanced pattern-matching
+ " capabilities so that we won't match leading spaces.
+ syn match adaKeyword	"\<with\>"
+ syn match adaKeyword	"\<use\>"
+ if version < 600
+  syn match adaBeginWith "^\s*\(\(with\(\s\+type\)\=\)\|\(use\)\)\>" contains=adaInc
+  syn match adaSemiWith	";\s*\(\(with\(\s\+type\)\=\)\|\(use\)\)\>"lc=1 contains=adaInc
+ else
+  syn match adaBeginWith "^\s*\zs\(\(with\(\s\+type\)\=\)\|\(use\)\)\>" contains=adaInc
+  syn match adaSemiWith	";\s*\zs\(\(with\(\s\+type\)\=\)\|\(use\)\)\>" contains=adaInc
+ endif
+ syn match adaInc	"\<with\>" contained contains=NONE
+ syn match adaInc	"\<with\s\+type\>" contained contains=NONE
+ syn match adaInc	"\<use\>" contained contains=NONE
+ " Recognize "with null record" as a keyword (even the "record").
+ syn match adaKeyword	"\<with\s\+null\s\+record\>"
+ " Consider generic formal parameters of subprograms and packages as keywords.
+ if version < 600
+  syn match adaKeyword	";\s*with\s\+\(function\|procedure\|package\)\>"
+  syn match adaKeyword	"^\s*with\s\+\(function\|procedure\|package\)\>"
+ else
+  syn match adaKeyword	";\s*\zswith\s\+\(function\|procedure\|package\)\>"
+  syn match adaKeyword	"^\s*\zswith\s\+\(function\|procedure\|package\)\>"
+ endif
+endif
+
+
+" String and character constants.
+syn region  adaString		start=+"+  skip=+""+  end=+"+
+syn match   adaCharacter	"'.'"
+
+" Todo (only highlighted in comments)
+syn keyword adaTodo contained	TODO FIXME XXX
+
+" Comments.
+syn region  adaComment	oneline contains=adaTodo start="--"  end="$"
+
+
+
+" Define the default highlighting.
+" For version 5.7 and earlier: only when not done already
+" For version 5.8 and later: only when an item doesn't have highlighting yet
+if version >= 508 || !exists("did_ada_syn_inits")
+  if version < 508
+    let did_ada_syn_inits = 1
+    command -nargs=+ HiLink hi link <args>
+  else
+    command -nargs=+ HiLink hi def link <args>
+  endif
+
+  " The default methods for highlighting. Can be overridden later.
+  HiLink adaCharacter	Character
+  HiLink adaComment	Comment
+  HiLink adaConditional	Conditional
+  HiLink adaKeyword	Keyword
+  HiLink adaLabel	Label
+  HiLink adaNumber	Number
+  HiLink adaSign	Number
+  HiLink adaOperator	Operator
+  HiLink adaPreproc	PreProc
+  HiLink adaRepeat	Repeat
+  HiLink adaSpecial	Special
+  HiLink adaStatement	Statement
+  HiLink adaString	String
+  HiLink adaStructure	Structure
+  HiLink adaTodo	Todo
+  HiLink adaType	Type
+  HiLink adaTypedef	Typedef
+  HiLink adaStorageClass	StorageClass
+  HiLink adaBoolean	Boolean
+  HiLink adaException	Exception
+  HiLink adaInc	Include
+  HiLink adaError	Error
+  HiLink adaSpaceError	Error
+  HiLink adaBuiltinType Type
+
+  if exists("ada_begin_preproc")
+   " This is the old default display:
+   HiLink adaBegin	PreProc
+   HiLink adaEnd	PreProc
+  else
+   " This is the new default display:
+   HiLink adaBegin	Keyword
+   HiLink adaEnd	Keyword
+  endif
+
+  delcommand HiLink
+endif
+
+let b:current_syntax = "ada"
+
+" vim: ts=8
